[{"title":"一句话说清WeakMap的弱引用","url":"/weakmap/","content":"\nWeakMap的引用是弱引用，gc的时候会忽略这种引用。即如果一个对象只有这种弱引用的时候，\n会直接被垃圾回收掉。\n\n我们用代码看下和Map的差别，\n```\nlet obj = { name: 'fedaily' }\nconst map = new Map()\nmap.set('account', obj)\nmap.get('account') // { name: 'fedaily' }\n\nobj = null // 这里将obj置为null\nmap.get('account') // 这里其实obj值还在 { name: 'fedaily' }\n```\n\n从Map这个例子可以看出来，obj被map一直引用着，那么垃圾回收器处理时认为{ name: 'fedaily' }还有其他引用，就不会回收它。如果需要彻底删除它，需要map.delete('account')。\n\n我们再来看下WeakMap:\n```\nlet obj = { name: 'fedaily' }\nconst weakmap = new WeakMap()\nweakmap.set(obj, 'account') // WeakMap的key必须是对象，具体用法这里不展开，可以看MDN上的介绍\nweakmap.get(obj) // { name: 'fedaily' }\n\nobj = null // 这里将obj置为null\nweakmap.get('account') // undefined 这里就没有了\n```\n\n这里当我们将obj置为null的时候，obj整个就被垃圾回收了。包括weakmap里面保存的值。\n\n通过这两个对比，我们很容易理解WeakMap描述的对键对象的引用是弱引用的含义。\n\nWeakMap还有一个特性就是无法遍历所有的key。是这种弱引用特性导致的。\n\n还是以上面那个例子说明，当obj=null的时候，如果垃圾回收器没有执行，那么这个时候weakmap.get(obj)其实是有值的，但如果垃圾回收器执行过了，你再访问weakmap.get(obj)就是返回undefined了。\n\n所以这就导致了WeakMap无法遍历所有key的问题。\n\n希望这些可以帮你理解掌握该在什么时候用WeakMap，什么时候用Map。","tags":["JavaScript"]},{"title":"第34期 你真的理解setState吗 & 探索React的内在—Fiber&Algebraic Effects & 成为自信的node.js开发者（二）","url":"/hotlink34/","content":"\n[你真的理解setState吗？](https://mp.weixin.qq.com/s/H93e3K3E95dCPZpPSWR8Tw)\n\n面试官：“react中setState是同步的还是异步？”\n\n我：“异步的，setState不能立马拿到结果。”\n\n面试官：“那什么场景下是异步的，可不可能是同步，什么场景下又是同步的？”\n\n我：“......”\n\n[如何使用深度学习识别 UI 界面组件？](https://mp.weixin.qq.com/s/bE__yI4sarbaJnYTBc414g)\n\n本文介绍了使用机器学习的方式来识别 UI 界面元素的完整流程，包括：现状问题分析、算法选型、样本准备、模型训练、模型评估、模型服务开发与部署、模型应用等。\n\n[探索 React 的内在 — Fiber & Algebraic Effects](https://mp.weixin.qq.com/s/7MQp1CrZFwNd4dQ3y2C-UA)\n\n对于大部分前端开发者来说，在谈到 Fiber 的时候，第一反应想到的大概就是 React 的“新” Reconciler 架构\n\n然而，就 Fiber 本身来说，在计算机领域并非多么新潮的概念，其早在 1996 年就红极一时，在不同的应用中有各种各样的实践，其中最负盛名的大概就是 Microsoft Windows 中的用户线程架构了（还有 Symbian OS 哦）\n\n那么我们就从 Fiber 本身触发，来理解一下它到底是干什么的\n\n[支付宝小程序 V8 Worker 技术演进](https://mp.weixin.qq.com/s/QS0QT7TIcEzZhR6asCOecg)\n\n阿里妹导读：本文分享支付宝小程序 V8 Worker 相关工作沉淀和总结，包括技术演进、基础架构、基础功能、以及 JS 引擎能力输出，以及一些优化方案等。欢迎同学们共同探讨，指正。\n\n[成为自信的node.js开发者（二）](https://mp.weixin.qq.com/s/LC5yIzk22aao_7A3_flg5g)\n\n这一章，我们来学习一下event_loop, 本文内容旨在厘清浏览器（browsing context）和Node环境中不同的 Event Loop。\n\n[你不知道的 Blob](https://mp.weixin.qq.com/s/lQKTCS_QB0E62SK9oXD4LA)\n\n如果你允许用户从你的网站上下载某些文件，那你可能会遇到 Blob 类型。为了实现上述的功能，你可以很容易从网上找到相关的示例，并根据实际需求进行适当的调整。对于部分开发者来说，在完成上述功能之后，他们并不会继续思考 Blob 是什么？\n\n**公众号: 前端收藏家。只收藏好的，只推荐好的**"},{"title":"第33期 Promise/async/Generator实现原理解析 & 使用Node.js搭建一个 API 网关 & 你想要的WebAssembly入门与实践","url":"/hotlink33/","content":"\n[你想要的WebAssembly入门与实践](https://mp.weixin.qq.com/s/COqyiord3RGjTFXI8mBnVA)\n\nWebAssembly是由主流浏览器厂商组成的 W3C 社区团体 制定的一个新的规范。WebAssembly/wasm WebAssembly 或者 wasm 是一个可移植、体积小、加载快并且兼容 Web 的全新格式\n\n[巧用 display: contents 增强页面语义](https://mp.weixin.qq.com/s/7aOxWsN6v-vU00ML1Mhu_A)\n\ndisplay: contents 是一个比较陌生的属性，虽然属于 display 这个基本上是最常见的 CSS 属性，但是 contents 这个取值基本不会用到。但是它早在 2016 年就已经得到了 Firefox 的支持。\n\n[Promise/async/Generator实现原理解析](https://mp.weixin.qq.com/s/_YxwV2umR7PH-R2ouCepSQ)\n\n笔者刚接触async/await时，就被其暂停执行的特性吸引了，心想在没有原生API支持的情况下，await居然能挂起当前方法，实现暂停执行，我感到十分好奇。好奇心驱使我一层一层剥开有关JS异步编程的一切。阅读完本文，读者应该能够了解：\n* Promise的实现原理\n* async/await的实现原理\n* Generator的实现原理\n\n[用TypeScript编写React的最佳实践](https://mp.weixin.qq.com/s/CeFQ23aIiGbXRwY0eBawfg)\n\n如今， React 和 TypeScript 是许多开发人员正在使用的两种很棒的技术。但是把他们结合起来使用就变得很棘手了，有时很难找到正确的答案。不要担心，本文我们来总结一下两者结合使用的最佳实践。\n\n[使用 Node.js 搭建一个 API 网关(助力微服务)](https://mp.weixin.qq.com/s/gR4uI0IsXsk2Je33n850Lw)\n\n外部客户端访问微服务架构中的服务时，服务端会对认证和传输有一些常见的要求。API 网关提供共享层来处理服务协议之间的差异，并满足特定客户端（如桌面浏览器、移动设备和老系统）的要求。\n\n[未来的JavaScript记录与元组](https://mp.weixin.qq.com/s/uR6M2Rx_iMVH5GAbNpsxVA)\n\n记录和元组是一个新提案（Record & Tuple，https://github.com/tc39/proposal-record-tuple），建议为JavaScript增加两个复合原始类型：\n\n* 记录（Record），是不可修改的按值比较的对象\n* 元组（Tuple），是不可修改的按值比较的数组\n\n**公众号: 前端收藏家。只收藏好的，只推荐好的**","tags":["精选"]},{"title":"第32期 vite 一种新的、更快地 web 开发工具 & 如何实现高性能的在线 PDF 预览","url":"/hotlink32/","content":"\n[vite 一种新的、更快地 web 开发工具](https://mp.weixin.qq.com/s/xdg1NIZYdNQgbunVUGh38w)\n\nVite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。\n\n[如何用Canvas拍出JDer's工作照](https://mp.weixin.qq.com/s/2nA_9iff2x_9dlPal_TWyQ)\n\n给大佬、超级大佬拍照的文化，还是有意思的。\n\n[如何实现高性能的在线 PDF 预览](https://mp.weixin.qq.com/s/Wx_gJLrZftJ_dm2phoUf8g)\n\n最近接到产品需求，用户需要在我们的站点上在线查看 PDF 文件，并且查看时，用户可以对 PDF 文件的进行旋转、缩放、跳转到指定页码等操作。\n\n[一篇搞定移动端适配](https://mp.weixin.qq.com/s/Hf7vUOZcpE9wpsuLLsEp5w)\n\n手机市场日渐丰富的同时，给我们前端开发人员带来的 “网页内容自适应屏幕尺寸进行显示的问题” 也日渐凸显出来，接下来我们就要细说移动端适配的前世今生及方案。\n\n[如何快速将你的SPA应用改造成PWA应用](https://mp.weixin.qq.com/s/ShWfJLh5pi2BxHaUdzrsUQ)\n\nPWA是指渐进式web应用，一般由web app manifest, service worker, app shell, notification push等部分组成。\n\n[为什么HTTPS比HTTP更安全?](https://mp.weixin.qq.com/s/_ozg0qPtBHSQW8414dpapw)\n\n近几年，互联网发生着翻天覆地的变化，尤其是我们一直习以为常的HTTP协议，在逐渐的被HTTPS协议所取代，在浏览器、搜索引擎、CA机构、大型互联网企业的共同促进下，互联网迎来了“HTTPS加密时代”，HTTPS将在未来的几年内全面取代HTTP成为传输协议的主流。\n\n**公众号: 前端收藏家。只收藏好的，只推荐好的**","tags":["精选"]},{"title":"js 如何实现深拷贝deepClone","url":"/deepclone/","content":"\n如果不考虑RegExp, Function, Symbol, 循环引用的问题，那么使用JSON是一个不错的选择。\n\n比如有这样一个对象：\n```js\nvar target = {\n  name: 'fedaily',\n  age: 1,\n  topics: ['react', 'vue', 'css']\n}\n\nvar copyTarget = JSON.parse(JSON.stringify(target))\nconsole.log(copyTarget) // { name: 'fedaily', age: 1, topics: ['react', 'vue', 'css'] }\n\ncopyTarget.topics.push('webpack')\n\n// target不变\nconsole.log(target) // { name: 'fedaily', age: 1, topics: ['react', 'vue', 'css'] }\n```\n\n但是如果需要考虑各种引用类型，以及循环引用等问题，那么还是需要手动实现这些拷贝逻辑，这里参照lodash深拷贝的实现逻辑，但是精简了很多，我们来看看如何做：\n```js\nconst regexpTag = '[object RegExp]'\n\nfunction deepClone(value, stack = new WeakMap()) {\n  if (!isObject(value)) {\n    return value\n  }\n\n  let result = Array.isArray(value) ? [] : {}\n\n  // 函数直接返回\n  if (typeof value === 'function') {\n    return value\n  }\n\n  // 处理引用类型的拷贝\n  result = initCloneByTag(value, getTag(value))\n\n  // 处理循环引用\n  if (stack.has(value)) {\n    return stack.get(value)\n  }\n  stack.set(value, result)\n\n  // 这里没有处理key是Symbol的情况\n  // for in 不会枚举Symbol的key\n  // 可以通过Object.getOwnPropertySymbols获取所有Symbol的key\n  for (let key in value) {\n    result[key] = deepClone(value[key], stack)\n  }\n  return result\n}\n\nfunction isObject (value) {\n  const type = typeof value\n  return value != null && (type === 'object' || type === 'function')\n}\n\nfunction getTag(value) {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]'\n  }\n  return Object.prototype.toString.call(value)\n}\n\nfunction cloneRegExp(regexp) {\n  const result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp))\n  result.lastIndex = regexp.lastIndex\n  return result\n}\n\nfunction initCloneByTag(object, tag) {\n  const Ctor = object.constructor\n  // 可以在这里处理\n  // arrayBuffer, int32array, dataview等情况\n  switch (tag) {\n    case regexpTag:\n      return cloneRegExp(object)\n\n    default:\n      return {}\n  }\n}\n```","tags":["JavaScript"]},{"title":"第31期 技术人如何自我成长 & 还分不清 Cookie、Session、Token、JWT","url":"/hotlink31/","content":"\n[还分不清 Cookie、Session、Token、JWT？](https://mp.weixin.qq.com/s/X8nhBwyEUbq5zfM69XaHMA)\n\n文章详细分享了各种认证方式以及特点，还不熟悉的同学快来看看吧！\n\n[前端高频面试题整理 前端两年](https://mp.weixin.qq.com/s/0NzfGDvJMAlE2zpT-KSkzA)\n\n无论是刚入门的前端新手还是工作了几年的中高级前端 前端基础都是必须要牢牢掌握的 是不是有时候感觉到一个问题自己能回答出来七八分但是距离完美答案还是差点意思  那么此文章能帮助你快速突击前端高频次面试题 掌握之后轻松应对前端面试 祝大家都有好的offer！\n\n[技术人如何自我成长？](https://mp.weixin.qq.com/s/YoRf5Ui1ktOJ8MkeZXk_Aw)\n\n转眼 2020 已经快过去了一半，是时候来做一次年中总结了。阿里文娱高级技术专家箫逸总结了自己在阿里 6 年来的成长和收获，分享他在工作中的一些思维方法，以及对生活的一些感悟，希望对同学们有所启发。\n\n[手写async await的最简实现](https://mp.weixin.qq.com/s/em663Ctl7UxYwPWkm-hR2g)\n\n经常有人说async函数是generator函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。\n\n有的同学想说，既然用了generator函数何必还要实现async呢？\n\n这篇文章的目的就是带大家理解清楚async和generator之间到底是如何相互协作，管理异步的。\n\n[前端都该懂的浏览器工作原理，你懂了吗？](https://mp.weixin.qq.com/s/djTZ4z5bH1HVo3LhfGBwxA)\n\n在我们面试过程中，面试官经常会问到这么一个问题，那就是从在浏览器地址栏中输入URL到页面显示，浏览器到底发生了什么？这个问题看起来是老生常谈，但是这个问题回答的好坏，确实可以很好的反映出面试者知识的广度和深度。\n\n[桃翁同事裁员之际勇拿各大厂offer，最后上岸字节跳动](https://mp.weixin.qq.com/s/aCdNpBUxq8KHB6glOmbtEw)\n\n本人两年经验，目前已经接受了头条offer。最近一个月基本面试了很多大厂，结果也还不错，最终选择了头条。如果你有什么问题，可以加文末的微信，我们一起交流！\n\n本篇是面试题汇总篇，大厂的面试基本都是三面+hr面，所以，我会根据每个阶段的面试，来对面试题进行分类，从中总结面试经验。欢迎收藏和关注~\n\n**公众号: 前端收藏家。只收藏好的，只推荐好的**","tags":["精选"]},{"title":"第30期 边缘计算听说过吗？淘宝用它提升了69%的首屏性能 & 聊聊苹果营销页中几个有趣的交互动画 & Webpack5 上手测评","url":"/hotlink30/","content":"\n[如何使页面交互更流畅](https://mp.weixin.qq.com/s/E17nobsiQv36vbbx-TkDzw)\n\n本篇是基于 FDCon2019 上《让你的网页更丝滑by刘博文》的复盘文。该课题也是博主感兴趣的领域, 后续会结合 React 的 Schedule 与该文进行进一步整合, 个人博客\n\n[https 原理分析---带着疑问层层深入](https://mp.weixin.qq.com/s/OCwfu9BIHxasQF9ENxtC-g)\n\n随着 HTTPS 建站的成本下降，现在大部分的网站都已经开始用上 HTTPS 协议。大家都知道 HTTPS 比 HTTP 安全，也听说过与 HTTPS\n协议相关的概念有 SSL 、非对称加密、 CA证书等，但对于以下灵魂三拷问可能就答不上了：\n\n1. 为什么用了 HTTPS 就是安全的？\n2. HTTPS 的底层原理如何实现？\n3. 用了 HTTPS 就一定安全吗？\n本文将层层深入，从原理上把 HTTPS 的安全性讲透。\n\n[边缘计算听说过吗？淘宝用它提升了69%的首屏性能！](https://mp.weixin.qq.com/s/wgnMQzLbyXz0MNYQ_HibZg)\n\n在开始正题之前，我先讲一个内容详情的业务场景和其面临的性能问题, 图文内容详情业务本身有三个比较大的特点: \n* 内容量大，几十亿的内容量，并且每天还在疯狂增长\n* 流量大，为了支撑这么大的业务，需要很多服务器成本\n* 内容数据极具静态化，页面参考如下，除了蓝色标识的数据，其他数据很少会改动\n\n[提高10倍打包速度的神奇工具：Snowpack 2.0发布，再也不需要打包器！](https://mp.weixin.qq.com/s/7Z8U6rGVIpy1R406mNqD6g)\n\nnowpack 2.0 则是为了这个 Web 开发的新时代而设计的构建系统。Snowpack 利用原生 ES 模块（ESM）支持，将构建好的文件直接提供给浏览器，这样你的开发环境就不再需要打包器了。它不仅是一种速度更快的工具，更是一种全新的 Web 构建系统和构建方法。\n\n[聊聊苹果营销页中几个有趣的交互动画](https://mp.weixin.qq.com/s/-wRibFQVnJdrag4KfC-b2g)\n\n前两天在浏览 苹果 16寸 营销页面 的时候，发现了几个比较有意思的交互，心里想着自己虽然是一个穷逼，但是知识是无界限的呀，于是便研究了一波。\n\n[Webpack5 上手测评](https://mp.weixin.qq.com/s/Sfc4zmIFR-uUmCBScKBEzw)\n\n大家一定看过很多电子设备开箱测评，今天我们也来跑一个软件新版的上手测评 —— Webpack 5！\n\n[Babel插件开发&测试与简易源码分析](https://mp.weixin.qq.com/s/yeNy-N78G97Sz7r1eTEstg)\n\n本文主要从 Babel 基础 开始介绍，以一个例子完整阐述了插件的开发与测试如何进行，并在最后提供了简易的 Babel 代码解析及其他扩展资料\n\n**公众号: 前端收藏家。只收藏好的，只推荐好的**","tags":["精选"]},{"title":"第29期 写给初中级前端的高级进阶指南 & 前端性能优化：当页面渲染遇上边缘计算 & 平庸前端码农之蜕变 — AST","url":"/hotlink29/","content":"\n[写给初中级前端的高级进阶指南](https://mp.weixin.qq.com/s/v_emmx7alE2FdwWzHTcPAA)\n\n我曾经一度很迷茫，在学了Vue、React的实战开发和应用以后，好像遇到了一些瓶颈，不知道该怎样继续深入下去。相信这也是很多一两年经验的前端工程师所遇到共同问题，这篇文章，笔者想结合自己的一些成长经历整理出一些路线，帮助各位初中级前端工程师少走一些弯路。\n\n[平庸前端码农之蜕变 — AST](https://mp.weixin.qq.com/s/n9q7X_zMStZPVgn8vmFoJA)\n\n如果你查看目前任何主流的项目中的devDependencies，会发现前些年的不计其数的插件诞生。我们归纳一下有：javascript转译、代码压缩、css预处理器、elint、pretiier，等。有很多js模块我们不会在生产环境用到，但是它们在我们的开发过程中充当着重要的角色。所有的上述工具，不管怎样，都建立在了AST这个巨人的肩膀上。\n\n[前端需要懂的 APP 容器原理](https://mp.weixin.qq.com/s/_m_rf7xlSeVZO1NK58Z7lQ)\n\nApp 容器，简言之，App 承载某类应用（H5/RN/Weex/小程序/Flutter ...）的运行环境，可主动干预并进行功能扩展，达到丰富能力、优化性能、提升体验的目的，如页面数据预取（prefetch）缩短页面可用耗时、WebAR 将 AR 能力赋予 H5、Native 地图与 H5 复合渲染交互。\n\n[相见恨晚的 Git 命令动画演示，一看就懂！](https://mp.weixin.qq.com/s/CwO2owC0t8sMnuSOoEyebw)\n\n虽然 Git 是一个强大的工具，但是我觉得大部分人都会同意我说的：它也可以是一个……噩梦！我一直觉得，使用 Git 的时候把操作过程在脑海里视觉化会非常有用：当我执行某个命令的时候，分支之间是如何交互的？又是如何影响提交历史的？当我在master分支执行hard reset、force push到 origin、在.git文件夹执行rimraf的时候，为什么我的同事都哭了？\n\n[5种延迟加载图像的方法以帮助你提升网站性能与用户体验](https://mp.weixin.qq.com/s/b4DbvkkIwGvvSZhy_fBE1w)\n\n在本文中，你将了解5种延迟加载图像的方法，可以将它们添加到Web优化工具包中以改善网站上的用户体验。\n\n[前端性能优化：当页面渲染遇上边缘计算](https://mp.weixin.qq.com/s/Ez_GjA-eEGyE5izq6VKONA)\n\n对于 web 页面来说，首跳场景（例如 SEO、付费引流）的性能普遍比二跳场景下要差。原因有多种，主要是首跳用户在连接复用，和本地资源缓存利用方面，有很大的劣势。首跳场景下，很多在端上的优化手段（预加载，预执行，预渲染等）无法实施。\n\n在客户端缓存能力无法利用的情况下，利用 cdn 距离用户近的特性，可以结合缓存做一些性能优化。\n\n[XSS 最全攻防之战！](https://mp.weixin.qq.com/s/XzecUnT3RVB9T64iIKLYfw)\n\n在上世纪 90 年代，这种攻击主要是跨域攻击，而一个网站就是一个域名，所以叫“跨站脚本攻击”。但是发展到今天，是否跨域已经不重要了，由于这个历史原因，XSS 这个名字也一直延续至今。\n\n[读懂 TS 中联合类型和交叉类型的含义](https://mp.weixin.qq.com/s/kGd5gqgCnkgISNd-a8DlCg)\n\n联合类型在 TypeScript 中相当流行，你可能已经用过很多次了。交叉类型稍微不那么常见。它们似乎引起更多的困惑。\n\n你有没有想过这些名字是怎么来的？虽然你可能对两种类型的并集有一些直观感受，但交集通常不太容易理解。\n\n阅读本文之后，你将对这些类型有更好的了解，这将使你在代码中使用它们时更有信心。\n\n**公众号: 前端收藏家。只收藏好的，只推荐好的**","tags":["精选"]},{"title":"第28期 React Hooks深入系列 & JavaScript可视化：Promise和Async/Await & 基于Express应用框架的技术方案选型浅谈","url":"/hotlink28/","content":"\n[据说，80%的人都搞不懂哈希算法](https://mp.weixin.qq.com/s/O0YGl4U14CNRX_t27khq8w)\n\n聊到区块链的时候也少不了会听到“哈希”、“哈希函数”、“哈希算法”，是不是听得一头雾水？别急，这一讲我们来讲讲什么是哈希算法。\n\n[JavaScript可视化：Promise和Async/Await](https://mp.weixin.qq.com/s/oxGdVPLfkBH0vZ575tefhg)\n\n曾经不得不处理没有按照你期望的方式运行的JS代码吗？可能是函数被随机的、不可预测时间的执行，或者被延迟执行。你可能正在处理ES6引入的一个非常酷的新特性:Promise!\n\n我多年之前的好奇心已经得到了回报，在不眠的夜晚再次给了我时间来制作一些动画。是时候来谈论Promise了：为什么你要使用它们，它们在底层是如何工作的，以及我们如何能用最现代的方式来书写它们？\n\n[基于Express应用框架的技术方案选型浅谈](https://mp.weixin.qq.com/s/0vXYTyJgKFam7-EbvZShBQ)\n\n现在的 Node 对于前端而言可以涵盖各个方面，包括命令行接口、插件、依赖库、脚手架以及 Web 服务等。本文是一篇对于 Node 使用的浅谈文章，会简单讲解一些个人使用 Node 的经验，分享的内容主要可分为三个方面：\n1. 工具篇\n2. 插件篇\n3. 服务篇\n\n[React Hooks 深入系列](https://mp.weixin.qq.com/s/e8plCyb6aIQhJ2lg2mRUJQ)\n\n本文基于近段时间对 hooks 碎片化的理解作一次简单梳理, 个人博客。同时欢迎关注基于 hooks 构建的 UI 组件库 —— snake-design。\n\n[25个CodePen上激发你创作灵感的动画案例，附源码](https://mp.weixin.qq.com/s/ufVVXLdbQcpUZ4EcL-9LMg)\n\nCodePen是很多程序员用来展示代码创作的首选在线工具。今天，我为大家精选的25个CodePen上CSS动画展示案例，这些动画案例作品均来源于CodePen上，所有作品均归原创作者所有，我在这里只是与大家分享学习使用。\n\n**公众号: 前端收藏家。收集全网优秀前端技术资讯，与你分享，共同成长。**"},{"title":"如何快速将你的SPA应用改造成PWA应用","url":"/pwa/","content":"\nPWA是指渐进式web应用，一般由web app manifest, service worker, app shell, notification push等部分组成。\n\n这里目前只讨论web app manifest, service worker两部分如何应用到项目中。\n\nweb app manifest可以使应用变成可安装式的。可以通过浏览器将应用添加到桌面上，从而可以从桌面上直接访问，同时可以定义桌面图标、应用名称、系统状态栏颜色，通过这些，我们可以让我们的应用像一个原生APP一样。从而给用户更好的体验。\n\n从产品的角度来看，用户从桌面图标访问我们的应用肯定比通过浏览器去访问便捷的更多，同时还可以让用户访问的时候隐藏浏览器本身的一些控件，比如导航栏、底部设置等控件。而实现这一切只需要很小的代价。这一切只需要添加一个manifest.json文件即可。\n\n⚠️注意：在你开始跃跃欲试之前，请先确认你的应用是否全站https。如果不是，那么最好等你的应用全站https后再来尝试。\n\n#### Web App Manifest\n\n我们看下manifest.json文件是什么样的：\n\n[Web App Manifest 文档](https://developer.mozilla.org/zh-CN/docs/Web/Manifest)\n\n```json\n{\n  \"name\": \"前端收藏家\",\n  \"short_name\": \"fedaily\",\n  \"orientation\": \"portrait\",\n  \"display\": \"standalone\",\n  \"start_url\": \"/\",\n  \"description\": \"只收藏好的，只推荐好的\",\n  \"background_color\": \"#000\",\n  \"theme_color\": \"#000\",\n  \"icons\": [\n    {\n      \"src\": \"icon.png\",\n      \"sizes\": \"96x96\",\n      \"type\": \"image/png\"\n    },\n    // ... 可以添加多种尺寸的图标\n  ]\n}\n```\n\n针对iOS平台，我们需要使用标签的形式添加：\n\n[iOS application 官方文档](https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html)\n\n```html\n<link rel=\"apple-touch-icon\" href=\"icon.png\">\n<meta name=\"apple-mobile-web-app-title\" content=\"前端收藏家\">\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\">\n<meta name=\"theme-color\" content=\"#000000\">\n```\n\n然后在你的html中引入这个json文件即可。\n```html\n<link rel=\"manifest\" href=\"/manifest.json\">\n```\n\n⚠️注意，这里需要放在项目根目录下，否则会导致安卓不能自动弹出添加到桌面的提示（你可能会问，那iOS会有这个问题吗，没有，iOS根本就不支持这个特性）。\n\n当你做好这些，一个可以安装到桌面的应用就诞生了。\n\n你可以用Android的chrome浏览器访问你的应用，然后通过设置-添加到桌面功能，就可以将你的应用添加到桌面了。\n你可以用iOS的safari浏览器访问你的应用，然后通过底部的分享按钮-添加到主屏幕，就可以将你的应用添加到桌面了。\n\n#### Service Worker\n\nService worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。\n\nService worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。\n\n出于安全考量，Service workers只能由HTTPS承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。在Firefox浏览器的用户隐私模式，Service Worker不可用。\n\nservice worker具体的API以及详细介绍，大家可以在网上搜相关的资料，都说的很详细，这里介绍一个非常便捷的方法。\n\n[workbox webpack plugin](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin)可以和webpack集成，只需要很少的配置，就可以实现大部分我们需要的功能。\n\n我们看下如何使用：\n```js\nnew GenerateSW({\n  swDest: 'sw.js',\n  skipWaiting: true,\n  clientsClaim: true,\n  cleanupOutdatedCaches: true,\n  inlineWorkboxRuntime: true,\n  runtimeCaching: [{\n    handler: 'NetworkFirst',\n    urlPattern: /\\/api/,\n    method: 'GET',\n  }]\n})\n```\n\n这个插件会读取webpack本身构建出来的静态资源文件，比如.js, .css, .png等资源，将其添加到缓存列表中，所以不需要在这里再指定了。\n\n通过runtimeCaching，我们可以缓存比如api的返回值，这里⚠️建议慎重考虑，如果你不是特别在意应用在断网情况下的体验（作为一个web应用，大多数情况下，断网基本啥都干不了，所以尽量不要缓存api数据，缓存静态资源即可，缓存策略不合适的话，可能会导致一些意想不到的BUG🐛）\n\n这个插件会根据你的配置自动生成service worker文件，是不是很简单，然后你需要做的就是去你的html里面注册servie worker就可以了。\n```html\n<script>\n  if ('serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n      navigator.serviceWorker.register(`/sw.js?${Date.now()}`).then(registration => {\n        console.log('SW registered: ', registration)\n      }).catch(registrationError => {\n        console.log('SW registration failed: ', registrationError)\n      })\n    })\n  }\n</script>\n```\n\n⚠️注意：sw.js文件和manifest.json一样，也需要放在项目根目录下的。\n\n到这里，其实我们就有一个基本的可以使用的pwa化的应用了。\n\n如果你还需要一些定制化的需求可以详细阅读workbox文档去实现。\n\n### 开发中遇到的问题\n\n#### 安卓的chrome没有弹添加到桌面的弹窗\n检查你的manifest.json, sw.js文件是否在项目根目录下。以及sw是否注册成功。\n\n#### 安卓添加到桌面过程很慢\n暂时还没有找到好的解决方案\n\n#### 如何判断是否从主屏幕访问\n因为埋点等需求，我们需要区分用户是从浏览器访问的还是从主屏幕访问的，可以这样判断：\n```\nexport const isFromDesktop = () => {\n  // window.navigator.standalone used for safari\n  if (window.navigator.standalone) {\n    return true;\n  }\n  if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) {\n    return true;\n  }\n  return false;\n};\n```\n\n#### 如何监听添加到桌面事件\n```js\nlet deferredPrompt\nwindow.addEventListener('beforeinstallprompt', event => {\n  console.log('install event trigger', event);\n  // 禁止浏览器自动显示添加到桌面提示框\n  e.preventDefault();\n  // 存储事件对象，方便后面自定义弹窗时机\n  deferredPrompt = e;\n\n  // 然后可以显示一个自定义的提示框给用户，告诉用户\n  // 可以将应用添加到桌面，同时可以告知如何操作\n})\n\n// 再监听自定义提示框的按钮点击事件\nbuttonInstall.addEventListener('click', (e) => {\n  // 隐藏我们自定义的弹窗\n  hideMyInstallPromotion();\n  // 显示添加到桌面提示框（浏览器提供的）\n  deferredPrompt.prompt();\n  // 这里可以获取到用户的选择，同时做一些埋点相关操作\n  deferredPrompt.userChoice.then((choiceResult) => {\n    if (choiceResult.outcome === 'accepted') {\n      console.log('用户接受');\n    } else {\n      console.log('用户拒绝');\n    }\n  })\n});\n```\n\n#### 添加到主屏幕失败\n安卓浏览器添加到主屏幕权限可能没打开，如果没打开，也不会有添加到主屏幕那个提示框的，需要开启权限再次尝试（所以一个自定义的提示框还是很重要的，可以告知用户如何处理失败的情况，经过测试，因为权限导致的失败并没有什么提示给到用户）\n\n#### 如何捕捉安装成功动作\n```js\nwindow.addEventListener('appinstalled', (evt) => {\n  console.log('app installed', evt);\n})\n```\n\n#### 如何注销sw\n```js\n// registrations 是注册成功回掉的参数\nfor (let registration of registrations) {\n  registration.unregister()\n}\n```\n\n#### 如何降级\n建议配置一个接口，根据接口决定是否执行sw注册的流程，否则将已有的sw注销掉。这样可以很方便的处理线上问题。比如：\n```js\nfetch('/api/sw/').then(result => {\n  if (result) {\n    // 注册操作\n  } else {\n    // 注销操作\n  }\n})\n```\n\n写到这里，好像实际开发过程中问题还是挺多的，不过综合来看，PWA还是非常值得尝试的。毕竟体验大不同呀。\n\n后面遇到其他问题再更新，也欢迎大家积极留言交流。。。\n\n**公众号: 前端收藏家。收集全网优秀前端技术资讯，与你分享，共同成长。**","tags":["pwa"]},{"title":"第27期 这就是你日思夜想的React原生动态加载 & GraphQL到底怎么使 & 一文从零彻底搞懂前端的内存监控、异常、泄漏","url":"/hotlink27/","content":"\n[这就是你日思夜想的 React 原生动态加载](https://mp.weixin.qq.com/s/l_kv6rzUXSF3R9bfIko5BQ)\n\n在 React 16.6 版本中，新增了 React.lazy 函数，它能让你像渲染常规组件一样处理动态引入的组件，配合 webpack 的 Code Splitting，只有当组件被加载，对应的资源才会导入 ，从而达到懒加载的效果。\n\n[GraphQL到底怎么使？看看智联前端团队技术沉淀](https://mp.weixin.qq.com/s/Zps62tAV5gTVqkWUU8msqA)\n\n此文是作者考虑 GraphQL 在 Node.js 架构中的落地方案后所得。从最初考虑可以（以内置中间件）加入基础服务并提供完整的构建、发布、监控支持，到最终选择不改动基础服务以提供独立包适配，不限制实现技术选型，交由业务团队自由选择的轻量方式落地。中间经历了解除误解，对收益疑惑，对最初定位疑惑，最终完成利弊权衡的过程。\n\n[Chrome 83 发布，支持直接读写本地文件！新的跨域策略!](https://mp.weixin.qq.com/s/6fDoKE2bayKXvI5re-gfOg)\n\n受新冠疫情影响，Chrome 稳定版本的更新直接跳过 v82 来到 Chrome 83，因此很多原本在 Chrome 82上就要正式发布的功能也悉数积攒到了本次更新的 Chrome 83 中。\n\n[一文从零彻底搞懂前端的内存监控、异常、泄漏](https://mp.weixin.qq.com/s/wufb9IE0ptpMMUso7SZetQ)\n\n垃圾回收机制通常是使用标志清除策略，简单说，也就是引用从根节点开始是否可达来判定是否是垃圾\n\n上面是发生内存泄漏的根本原因，直接原因则是，当不同生命周期的两个东西相互通信时，一方生命到期该回收了，却被另一方还持有时，也就发生内存泄漏了\n\n所以，下面就来讲讲，哪些场景会造成内存泄漏\n\n[前端组件库本地开发调试的自动化流程实现](https://mp.weixin.qq.com/s/nOFKKCwUDCYW1HAGH25W-Q)\n\n如果不对项目进行设计，我们写的所有代码都会存于同一个仓库，当需要本地调试编码效果时，一条 npm run start 或者 npm run dev 便可把我们所需的服务启动，但随着时间推移，这个项目无法避免会成为一个「巨无霸」，而其带给我们的伤害会远大于收益，于是我们想到了拆分，那么，就将一些 UI 或者计算逻辑单独抽成包吧。\n\n[React源码揭秘(三)：Diff算法详解](https://mp.weixin.qq.com/s/e0fDbM5pp9bX1YuYBSXhLA)\n\n在上一篇文章这里3我们讲到，在render阶段的beginWork函数中，会将上次更新产生的 Fiber 节点与本次更新的 JSX 对象（对应ClassComponent的this.render方法返回值，或者FunctionComponent执行的返回值）进行比较。根据比较的结果生成workInProgress Fiber，即本次更新的 Fiber 节点。\n\n**公众号: 前端收藏家。收集全网优秀前端技术资讯，与你分享，共同成长。**","tags":["精选"]},{"title":"第26期 详解React 16的Diff策略 & 深入分析Session和Cookie & 图解ChunkSplitPlugin","url":"/hotlink26/","content":"\n[深入分析Session和Cookie](https://mp.weixin.qq.com/s/q83qhK9IfeQmvwjmXOkVyA)\n\n在Web发展史中，我们知道浏览器与服务器间采用的是 http协议，而这种协议是无状态的，所以这就导致了服务器无法知道是谁在浏览网页，但很明显，一些网页需要知道用户的状态，例如登陆，购物车等。\n\n所以为了解决这一问题，先后出现了四种技术，分别是隐藏表单域，URL重写，cookie，session，而用的最多也是比较重要的就是cookie和session了。\n\n[图解ChunkSplitPlugin](https://mp.weixin.qq.com/s/IHJoPUa5G8ENU3lbZBFE7A)\n\nchunk(module 的集合)在 webpack 解析的依赖图中以父子关系联系起来的。最初CommonsChunkPlugin被设计用于 chunk 之间避免重复依赖，但是性能远远不是最优解。\n\n在 webpack 4 中，内置了ChunkSplitPlugin用于替代CommonsChunkPlugin。\n\n以下基于官方 demo进行梳理，将主要的数据结构结合图示和个人的理解进行总结。\n\n揭开此插件的设计思路和源码神秘面纱\n\n[不可错过的实用前端工具](https://mp.weixin.qq.com/s/ISnuV4R1FSrySglXLkyeXQ)\n\n给大家整理了 25 个前端相关的学习网站和一些靠谱的小工具，包括一些小游戏、教程、社区网站和博客，以及一些资源网站，希望可以帮助到大家！\n\n[Deep In React之浅谈 React Fiber 架构(一)](https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484469&idx=1&sn=f68d044f1b0e4e2eb981e3878427b75b&scene=21#wechat_redirect)\n\n2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。\n\n我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。\n\n[详解 React 16 的 Diff 策略](https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484536&idx=1&sn=94777b8c1aab80dffe1fc224bec02c72&scene=21#wechat_redirect)\n\n我相信在看这篇文章的读者一般都已经了解过 React 16 以前的 Diff 算法了，这个算法也算是 React 跨时代或者说最有影响力的一点了，使 React 在保持了可维护性的基础上性能大大的提高，但 Diff 过程不仅不是免费的，而且对性能影响很大，有时候更新页面的时候往往 Diff 所花的时间 js 运行时间比 Rendering 和 Painting 花费更多的时间，所以我一直传达的观念是 React 或者说框架的意义是为了提高代码的可维护性，而不是为了提高性能的，现在所做的提升性能的操作，只是在可维护性的基础上对性能的优化。\n\n**公众号: 前端收藏家。收集全网优秀前端技术资讯，与你分享，共同成长。**","tags":["精选"]},{"title":"js 实现一个throttle节流函数","url":"/js-throttle/","content":"\n节流是指每隔一段时间，我们只执行一次动作。\n\n一般用于监听滚动事件等情况。当我们某个动作执行的很频繁，需要限制它执行的频率的时候，就可以使用节流函数。\n\n根据这些概念，我们先来实现一版看看原理：\n```javascript\nfunction throttle(fn, delay) {\n  let prevTime = 0\n  return function(...args) {\n    const now = new Date().getTime()\n    if (now - prevTime > delay) {\n      fn.apply(this, args)\n      prevTimer = now\n    }\n  }\n}\n```\n\n这种实现有一个问题就是最后一次动作会不执行，假设delay是1s，当我们第1.5s就不再触发的时候，实际上，我们只是在第0s，也就是第一次触发时候执行来，然后在第1s时候又执行了一次，但是我们其实是1.5s才停止的。\n\n所以有时候根据需要，我们其实也需要在最后一次的时候执行一次动作，那么怎么实现呢，可以借助于setTimeout来实现：\n```javascript\nfunction throttle(fn, delay) {\n  let prevTime = 0\n  let timer\n  return function(...args) {\n    const now = Date.now()\n    const remaining = delay - (now - prevTime);\n    // 如果第二次执行超过delay了就立即执行\n    // remaining > wait是为了处理修改了系统时间的情况\n    // 比如把当前系统时间往过去调了十分钟，那么now其实是比prevTime小的\n    // 那么remaning就可能是一个比较大的数了\n    if (remaining > 0 || remaining > wait) {\n      if (timer) {\n        clearTimeout(timer)\n        timer = null\n      }\n      fn.apply(this, args)\n      prevTimer = now\n    } else if (!timer) {\n      // 这里就是为了处理1.5s停止触发的情况\n      // 以1.5s为例，delay为1s，这个时候我们设置一个定时器\n      // 让它在0.5s后执行\n      // 这样在整个过程中，就是第0s, 第1s，第2s分别执行一次，共三次\n      // 虽然我们是1.5s就停止触发了\n      // 这样就保证了最后一次动作一直可以执行\n      timer = setTimeout(() => {\n        fn.apply(this, args)\n        timer = null\n        prevTime = Date.now()\n      }, remaining)\n    }\n  }\n}\n```","tags":["JavaScript"]},{"title":"js 实现一个debounce防抖函数","url":"/js-debounce/","content":"\ndebounce是指当函数被触发时，如果没有到我们设定的时间，函数不会执行，如果在设定时间之前多次触发，那么计时器会被重设，直到最后一次触发后过了设定的时间，函数才会真正执行。\n\n一般的应用场景是：input组件根据用户输入去做一些请求，比如联想词这种需求，这个时候我们尽量不要每当input的change事件触发就去请求，我们可以等用户停止输入后比如100ms再去请求。\n\n具体场景其实可以根据这个函数的实际功能然后结合业务需求去考虑是否使用。\n\n我们来看看如何实现：\n```javascript\nfunction debounce(fn, delay) {\n  let timer\n  return function(...args) {\n    if (timer) clearTimeout(timer)\n    // 使用箭头函数来处理this问题\n    timer = setTimeout(() => fn.apply(this, args), delay)\n  }\n}\n```\n\n这样，一个基础版的防抖函数就写好了。\n\n然后我们再来优化一下，实际使用中，我们可能需要让它第一次立即执行，然后后面延迟执行，这个需要怎么实现呢，我们来看一下：\n```javascript\nfunction debounce(fn, delay, immediate) {\n  let timer\n  let result\n  return function(...args) {\n    if (timer) clearTimeout(timer)\n\n    if (immediate) {\n      // 如果timer存在，说明第二次调用的时候还没到delay时间，因为如果超过delay时间\n      // timer会被赋值为null，所以这个时候我们不应该执行fn，应该重新设置一个定时器\n      // 但如果是一次的时候，因为还没有设过定时器，所以这里timer会是undefined\n      if (timer) {\n        timer = setTimeout(() => timer = null, delay)\n      } else {\n        result = fn.apply(this, args)\n        return result\n      }\n    } else {\n      timer = setTimeout(() => fn.apply(this, args), delay)\n    }\n  }\n}\n```\n\n实际的比如lodash.debounce会实现的比这个复杂一些，因为要考虑到很多种情况，但是基本的思想都在这里了。","tags":["JavaScript"]},{"title":"koa-compose源码解读","url":"/koa-compose-code/","content":"\n[koa-compose](https://github.com/koajs/compose/blob/master/index.js)\n\n我们先来看下如何使用compose：\n\n```\nfunction async m1(ctx, next) {\n  ctx.middleware.m1 = 'm1'\n  next()\n}\nfunction async m2(ctx, next) {\n  ctx.middleware.m2 = 'm2'\n  next()\n}\n\nconst middlewareFunc = componse([m1, m2])\n```\n\n当我们执行`middlewareFunc`的时候。首先我们执行m1()，当执行到m1内部的next方法时，这个next其实就是m2。然后再继续执行m2。\n\n那么compose是如何实现这种效果的呢，我们一步一步分解一下，首先我们知道compose会返回一个函数，然后这个返回的函数执行的时候，会依次执行传入的数组中的函数。同时每个函数会接收一个next，这个next指向数组中下一个函数。\n\n我们大概实现一版：\n```\nfunction compose(funs) {\n  return function(context) {\n    return funs[0](context, funs[1]);\n  }\n}\n```\n\n当然这个肯定是无法实际使用的，但是我们可以看到确实实现了next的这种特性。而且也无法处理任意长度funs的情况，我们来完善一下：\n```\nfunction compose(funs) {\n  return function(context) {\n    let index = -1\n    return dispatch(0)\n    function dispatch(i) {\n      index = i\n      return funs[i](context, funs[i + 1])\n    }\n  }\n}\n```\n\n这里我们利用闭包的特性保存来一个index，用这个来决定执行funs中的哪个函数。然后通过每次调用将index + 1实现m1调用的时候next是下一个函数也就是m2。\n\n其实这个就是compose的整个思想了，当然实际的koa-compose是返回的promise，同时考虑了一些异常处理，我们来看下最终的实现:\n```\nfunction compose (middleware) {\n  // 首先我们判断middleware是不是数组，以及数组中每个元素是不是function\n  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')\n  for (const fn of middleware) {\n    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')\n  }\n\n  return function (context, next) {\n    // index初始值为-1，因为第一次调用下标是0，同时需要判断index是否大于i，如果为0会和下面判断逻辑冲突\n    let index = -1\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('next() called multiple times'))\n      index = i\n      let fn = middleware[i]\n      if (i === middleware.length) fn = next\n      if (!fn) return Promise.resolve()\n      try {\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n```","tags":["javascript"]},{"title":"Object.assign的用法和注意点","url":"/js-object-assign/","content":"\nObject.assign可以实现对象的合并。它的语法是这样的：\n`Object.assign(target, ...sources)`\n\n`Object.assign`会将source里面的**可枚举属性**复制到`target`。如果和target的已有属性重名，则会覆盖。同时后续的source会覆盖前面的source的同名属性。\n\n⚠️Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。\n\n举例说明：\n```\nconst o1 = { name: 'fedaily' }\nconst o2 = { topic: ['react', 'nodejs'] }\nconst o3 = Object.assign({}, o1, o2)\n\n// o3 { name: 'fedaily', topic: ['react', 'nodejs'] }\no3.topic.push('css')\n\n// o3 { name: 'fedaily', topic: ['react', 'nodejs', 'css'] }\n// o2 { topic: ['react', 'nodejs', 'css'] }\n// ⚠️我们可以看到所有对象的topic值都被更新了\n```\n\n所以，当我们快乐的想要使用Object.assign的时候，需要特殊关注一下是否有引用类型哦。\n\n如果我们需要处理引用类型怎么办呢，这就涉及到对象的拷贝了，可以参考lodash的_clone, _cloneDeep等方法。\n\n再附上MDN关于Object.assign的polyfill，方便大家理解内部实现，同时更好的掌握这个方法哟\n```\nif (typeof Object.assign != 'function') {\n  Object.assign = function (target, varArgs) { // .length of function is 2\n    'use strict';\n    if (target == null) { // TypeError if undefined or null\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var to = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var nextSource = arguments[index];\n\n      if (nextSource != null) { // Skip over if undefined or null\n        for (var nextKey in nextSource) {\n          // Avoid bugs when hasOwnProperty is shadowed\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n    }\n    return to;\n  };\n}\n```\n\n### 前端收藏家（微信号: fedaily）收集全网优秀前端技术资讯，与你分享，共同成长。","tags":["JavaScript"]},{"title":"3年前端面试总结","url":"/fe-3-interview/","content":"\n> 持续更新中...\n\n### 一、javascript基础\n\n#### 合并两个数组\n```\n// 方法1: 使用concat, concat返回一个新数组，同时并不修改原数组\nconst a1 = [1]\nconst a2 = [2]\nconst a3 = a1.concat(a2) // [1,2]\n\n// 方法2: 使用扩展运算法\nconst a4 = [...a1, ...a2] // [1,2]\n\n// 其他方法: for循环遍历\n```\n\n#### 合并两个对象\n```\n// 方法1: Object.assign\n// ⚠️该方法只复制值，如果对象属性值是一个引用类型，那么就会复制引用地址，也就是说会存在引用共享的问题\nconst o1 = { name: 'fedaily' }\nconst o2 = { topic: 'fe' }\nconst o3 = Object.assign({}, o1, o2)\n```\n\n#### 实现koa的compose方法\n\n[koa-compose源码解读](https://juejin.im/post/5ec8f9a2518825430f54b6c7)\n\n#### 实现js new操作符效果\n[js new 操作符实际发生了什么](https://juejin.im/post/5ec8e337518825430044946e)\n\n```\nfunction newFactory() {\n  var obj = new Object()\n  Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype;\n  // 处理构造函数有返回值的情况\n  // 返回值如果是一个object则直接返回，否则返回obj\n  var ret = Constructor.apply(obj, arguments);\n  return typeof ret === 'object' ? ret : obj;\n};\n```\n\n#### js继承的几种实现方式\n\n[彻底弄清js继承的几种实现方式](https://juejin.im/post/5ec114095188256d545febbf)\n\n#### 模拟实现call, apply bind\n\n[如何模拟实现一个call、apply、bind函数](https://juejin.im/post/5ebbde296fb9a0433769777a)\n\n#### js实现一个debounce防抖函数\n\n[js 实现一个debounce防抖函数](https://juejin.im/post/5ec8eff4f265da76b4047da4)\n\n#### js实现一个throttle节流函数\n\n[js 实现一个throttle节流函数](https://juejin.im/post/5ec8f771f265da770a6156d1)\n\n#### 用 ES5 实现私有变量\n可以使用闭包实现：\n```javascript\nvar Tool = (function() {\n  var keyboard = 'hhkb'\n  return {\n    getKeyboard: function() {\n      return keyboard;\n    }\n  }\n})()\n\nTool.getKeyboard() // hhkb\nTool.keyboard // undefined\n```\n\n#### js基本数据类型\nnull, undefined, boolean, number, string, symbol, object\n\n#### 数组的常用操作方法以及是否修改原数组\n不会修改原数组：concat, entries, every, filter, find, findIndex, forEach, includes, indexOf, join, map, reduce, slice, some, sort, toString\n会修改原数组：fill, pop, push, reverse, shift, splice, unshift\n\n#### 什么是闭包？它有什么作用？\n闭包就定义在一个函数内部的函数，并且它引用了其外部函数的变量。\n主要用于获取函数内部变量以及让变量始终保持在内存中。可以实现一些抽象封装的逻辑，比如私有变量。\n闭包会导致变量一直保存在内存中，过量或者使用不当会造成内存泄漏以及性能问题。\n\n#### 什么是箭头函数？和普通函数有什么区别\n箭头函数是ES6提供的一种创建函数的新语法。\n1. 箭头函数没有自己的this，它的this总是指向外层执行环境的this，它的this在定义时候就已经决定了，并且永远不会改变\n2. 箭头函数不能作为构造函数使用，因为它没有自己的this，使用new的时候会报类型错误，提示其不是一个构造函数\n3. 箭头函数没有arguments对象，可以使用扩展运算符获取所有参数，比如const foo = (...args) => consle.log(args)\n4. 箭头函数没有prototype\n5. 箭头函数不能作为generator函数，不能使用yield关键字\n\n#### 如何实现一个深拷贝\n\n[js 如何实现深拷贝deepClone](https://juejin.im/post/5ed3768ef265da77031b6278)\n\n#### script module\n\n浏览器原生支持的模块系统，用法和es6的module类似，通过给script标签添加一个type='module'属性来实现。更高效。\n\n#### 手写Promise.all, Promise.race实现\n\n```js\n// Promise.all\nPromise.prototype.all = function(promises) {\n  return new Promise((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Promise.all param must be array'))\n    }\n    let resolvedCount = 0\n    const resolvedValues = []\n    for(let i = 0; i < promises.length; i++) {\n      Promise.resolve(premises[i]).then(value => {\n        resolvedCount++\n        resolvedValues.push(value)\n        if (resolvedCount === promises.length) {\n          return resolve(resolvedValues)\n        }\n      }, error => {\n        return reject(error)\n      })\n    }\n  })\n}\n\n// Promise.race\nPromise.prototype.race = function(promises) {\n  return new Promise((resolve, reject) => {\n    for (let i = 0; i < promiseAry.length; i++) {\n      promiseAry[i].then(resolve, reject)\n    }\n  })\n}\n```\n\n#### 什么是事件循环？这个循环会一直下去么，宏任务和微任务的区别？如果在Event Loop中，不断push微任务是否一直会执行\n\n// TODO:\n\n#### import 和 require 导入的区别\n\n// TODO:\n\n#### require 有什么性能问题\n\n// TODO:\n\n#### webpack 如何实现动态加载\n\n// TODO:\n\n#### webpack打包原理\n\n#### webpack的性能优化如何做\n\n#### webpack的loader和Plugins有什么区别，webpack是如何去使用Plugins的\n\n// TODO\n\n#### 写一个 promise 重试函数，可以设置时间间隔和次数。function foo(fn, interval, times) {}\n\n#### 手写promise的sleep函数实现\n\n// TODO:\n\n#### 实现一个 redux\n\n// TODO:\n\n#### 小程序架构，小程序的同层渲染原理，小程序的bindtap和catchtap的区别，小程序的通信是怎么样的，小程序的setData的数据如何很大，如何解决, webview组件和原生组件的区别\n\n// TODO:\n\n#### 请求超时timeout的原理\n\n--- \n\n### 二、typescript\n\n#### interface 和 type 的区别\n* interface会创建一个新的类型名称，可以在任何地方使用。但是type只是一个引用。\n* interface支持extends和implements，但是type不支持，不过可以通过交叉类型实现类似extends效果。\n* 尽量使用interface代替type，不过如果遇到需要使用联合类型或者元组的时候，我们还是使用type。\n\nhttps://juejin.im/post/5ec0ff23f265da7bed6b3c85 这里有更详细的解释\n\n#### typescript优势\n我理解的优势都是静态类型校验带来的，比如稳定性，团队协作，大型项目的维护。完善的类型系统可以让新成员很快的了解项目细节，同时一个完善的类型系统也完全可以充当项目文档。\n* 静态类型校验\n* 团队协作，类型即文档\n\n#### 实现Pick\n```typescript\ntype Pick<T, K extends keyof T> = { [P in K]: T[P] }\n```\n\n### 三、React\n\n#### React事件机制\nReact使用的合成事件，所有事件都是统一注册到document(一些原生的的事件不是，比如input的invalid事件，应该是因为这个事件只能在当前元素触发)。然后根据事件冒泡机制，统一在document上进行处理，这样可以提高性能，如果每个事件都绑定在真实DOM上，那么创建DOM，更新DOM时还需要处理事件，而且一个元素上如果同时绑定了很多事件，也会影响内存和页面响应。（可以对比事件委托来理解，传统开发模式下，如果需要给ul下面的所有li添加click事件的时候，我们也不会直接在每个li上绑定事件，而是绑定在ul上，然后根据事件冒泡机制来处理）\n\n同时React还在底层对事件做了兼容性处理。\n\n#### React如何做性能优化\n一方面从控制render以及减少计算方面入手。\n控制render也就减少了React的diff过程，常用不同类型组件的一些手段比如shouleComponentDidUpdate, React.memo。还可以使用useCallback避免函数的更新导致的render，因为函数式组件其实每次都会创建一个新的函数。\n减少计算可以通过useMemo缓存计算结果，只在必要的时候计算。\n\n另一方面从减少代码体积方面入手\n可以使用React.lazy配合webpack实现组件的懒加载。\n\n#### React的diff策略，React 16和之前版本diff有什么不同\n\n// TODO:\n\n#### React的生命周期的理解，以及16和之前版本区别，为什么有这种区别？\n\n// TODO:\n\n#### React Hooks怎么处理生命周期\n\n// TODO:\n\n#### class 组件与函数式组件的区别\n\n[函数式组件与类组件有何不同？](https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/)\n\n#### React.lazy 的原理是啥\n\n// TODO:\n\n#### react-redux原理\n\n// TODO:\n\n#### React的setState的机制是什么\n\n// TODO\n\n#### 描述一下redux的中间件原理，redux如何进行异步处理\n\n// TODO\n\n#### React hooks的优点\n\n// TODO\n\n#### Dva的同步状态管理，异步状态管理，是如何实现的\n\n### 四、CSS\n\n#### flex 0 1 auto表示什么意思\n是flex-grow(定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大), flex-shrink(定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。), flex-basis(定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小)\n\n#### css优先级\nimportant > 内联 > ID 选择器 > 类选择器 > 标签选择器\n\n#### css选择器\n\n// TODO\n\n#### 移动端适配方案\n\n// TODO\n\n#### flex的布局了解么，什么是主轴，如何控制主轴和副轴，Flex的优点和缺点\n\n// TODO\n\n#### 如何实现水平垂直居中\n```css\n.box {\n  display: flex;\n  jutify-content: center;\n  align-items: center;\n}\n\n.box {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translateX(-50%)\n  transform: translateY(-50%)\n}\n```\n\n#### 什么是BFC，它的作用是什么，什么行为会产生BFC\n\n// TODO\n\n#### css的动画如何实现, transform有什么好处\n\n// TODO\n\n#### 回流和重绘的区别，什么行为会导致回流，什么行为会导致重绘\n\n// TODO\n\n#### CSS3里面新增了哪些属性\n\n// TODO\n\n#### 1px的问题可以如何去解决\n\n// TODO\n\n#### less, sass 用过哪些函数\n\n// TODO\n\n#### 如何通过CSS实现一个梯形\n\n---\n\n### 浏览器\n\n#### 描述一下浏览器页面渲染的过程\n\n// TODO\n\n#### 浏览器白屏是什么导致的\n\n// TODO\n\n#### 浏览器存储Cookie、localstorage、sessionStorage的区别\n\n// TODO\n\n#### cookie如何进行设置的，JS能改变哪些值\n\n// TODO\n\n#### 解决跨域的方法有哪几种，描述一下JSONP的原理，描述一下CORS的过程\n\n// TODO\n\n#### 进程和线程\n\n#### 移动端的性能优化\n\n#### 如何进行首屏加载优化\n\n---\n\n### 五、算法\n\n#### 求字符串数组的最长公共前缀\n```\nvar longestCommonPrefix = function(strs) {\n    if (strs === null || strs.length === 0) return \"\";\n    if(strs.length === 1) return strs[0]\n    let min = 0, max = 0\n    // ⚠️精髓在这里\n    // 仔细看，我们并不是比较数组中某一个字符串的长度，而是大小，'s' > 'a' 直接这样比较的\n    // 这种比较其实比较的就是字符串每个字符的charCode\n    // 比如's'.charCodeAt()是115，而'a'是97，所以's' > 'a' 返回true\n    // 这里其实是筛选字符串公共前缀最长和最短的元素\n    // 以[\"flower\",\"flow\",\"flight\"]为例，公共前缀都是'fl'\n    // 其实最长和最短随便是那个都没有关系，我们根据charCode算出最长或者最短即可\n    // 我们再看，以[\"flower\",\"flow\",\"slight\"]为例，公共前缀都是''\n    // for循环结束后，strs[max]其实是'slight'，因为s比f的charCode大，所以'slight'就比f开头的所有字符串大\n    // strs[min]其实就是'flow'，因为'flower'比它多了e。\n    // 知道strs[min] strs[max]之后，以min为模板，去比较和max有多少重复的就可以了\n    for(let i = 1; i < strlength; i++) {\n        if(strs[min] > strs[i]) min = i\n        if(strs[max] < strs[i]) max = i\n    }\n    for(let j = 0; j < strs[min].length; j++) {\n        if(strs[min].charAt(j) !== strs[max].charAt(j)) {\n            return strs[min].substring(0, j)\n        }\n    }\n    return strs[min]\n};\n```\n\n#### 寻找最长不重复子串\n\n#### js实现一个单链表，双向链表\n\n#### 怎么判断单链表相交\n\n#### 怎么找到链表第一个相交节点\n\n#### 实现一个sum方法【sum(1, 2, 3)(4)，sum(1, 2)(3, 4)类似的调用】，同时console.log(sum(1, 2, 3)(4) => //输出10\n\n#### 给定一个先增后降的数组，找出其中的最大值\n\n#### 如何实现两个有序数组的合并，要求时间复杂度是O(n)\n\n### 六、HTTP以及安全相关\n\n#### HTTP缓存\n\n[HTTP缓存](https://juejin.im/post/5ec8e46c518825432c75514b)\n\n#### HTTP三次握手四次挥手\n\n[HTTP三次握手四次挥手](https://juejin.im/post/5ec8e41ce51d45788446825e)\n\n#### xss是什么，如何防范\n\n#### csrf是什么，如何防范\n\n#### HTTP1.1/HTTP2.0的区别，http3\n\n\n---\n\n### node\n\n#### node内存泄漏的原因\n\n---\n\n### 项目\n\n#### 项目中遇到的问题，如何解决的\n\n#### 项目中还有什么需要改进的地方\n\n#### 在公司有啥技术贡献\n\n#### 自己最大的成长是什么\n\n#### 自己觉得在原公司的开发流程上，还有哪些可以改进的\n\n#### 自己未来的职业规划是怎样的\n\n#### 平时如何进行学习的，目前在学习什么【慎重回答，这是面试的扩展点】","tags":["面试"]},{"title":"第25期 深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系 & 精读《@umijs/use-request》源码","url":"/hotlink25/","content":"\n[为什么你的网页需要 CSP?](https://mp.weixin.qq.com/s/QAuTBQUAc3K9ru1mPtCPbA)\n\nCSP 的主要好处就是可以全面禁止使用不安全的嵌入式 JavaScript。内联 JavaScript（无论是反射的还是存储的），意味着不正确的转义用户输入都可以被 Web 浏览器解释为 JavaScript 代码。通过使用 CSP 禁用嵌入式 JavaScript，你可以有效消除针对你站点的几乎所有 XSS 攻击。\n\n[Lighthouse 6.0 新功能](https://mp.weixin.qq.com/s/7Q_CTnOkXGH_8QCDhmvh1A)\n\n5月19日，Lighthouse 发布了 6.0 版本，带来了非常多的新特性，让我们一起来了解一下吧！\n\n[精读《@umijs/use-request》源码](https://mp.weixin.qq.com/s/ZbIiwSTurQXw6qu2rJwkJA)\n\n与组件生命周期绑定的 Utils 非常适合基于 React Hooks 来做，比如可以将 “发请求” 这个功能与组件生命周期绑定，实现一些便捷的功能。\n\n这次以 @umijs/use-request 为例子，分析其功能思路与源码。\n\n[深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系](https://mp.weixin.qq.com/s/Bh-nveCyLqkEDGQXri-8fg)\n\n关于 Event Loop 的文章很多，但是有很多只是在讲「宏任务」、「微任务」，我先提出几个问题：\n\n* 每一轮 Event Loop 都会伴随着渲染吗？\n* requestAnimationFrame 在哪个阶段执行，在渲染前还是后？在 microTask 的前还是后？\n* requestIdleCallback 在哪个阶段执行？如何去执行？在渲染前还是后？在 microTask 的前还是后？\n* resize、scroll 这些事件是何时去派发的。\n\n[node_modules 困境](https://mp.weixin.qq.com/s/uJeRnCOqsg1QVXbZwYzWAw)\n\nRyan 对于 node.js 的十大遗憾之一就是支持了 node_modules，node_modules 的设计虽然能满足大部分的场景，但是其仍然存在着种种缺陷，尤其在前端工程化领域，造成了不少的问题，本文总结下其存在的一些问题，和可能的改进方式。\n\n### 公众号: 前端收藏家。收集全网优秀前端技术资讯，与你分享，共同成长。","tags":["精选"]},{"title":"第24期 大规格文件的上传优化 & Node进阶—事无巨细手写Koa源码 & Nginx 负载均衡和缓存服务实战","url":"/hotlink24/","content":"\n[Reactive 架构才是未来](https://mp.weixin.qq.com/s/01SQuSYkNSHQz-0cbxzh_g)\n\nReactive 编程模型有哪些价值？它的原理是什么？如何正确使用？本文作者将根据他学习和使用的经历，分享 Reactive 的概念、规范、价值和原理。欢迎同学们共同探讨、斧正。\n\n[Lighthouse 测试内幕](https://mp.weixin.qq.com/s/I8DYY4oY_uJ_6IpIQNLSYQ)\n\n云音乐前端性能监控平台，底层使用了 Lighthouse 进行审计评分，在实践过程中我们积累了一些 Lighthouse 内部实现的研究经验，希望通过这篇文章可以分享给各位读者。\n\n[Node进阶—事无巨细手写Koa源码](https://mp.weixin.qq.com/s/QRjlAoSAtJOitKEpcOOlLg)\n\nKoa官网上说：“Koa提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序”。这套优雅的方法是什么？是如何实现的？让我们一探究竟，并手写源码。\n\n[深入探索 CSS Grid](https://mp.weixin.qq.com/s/Du2Qy2EmxK0Decr3ER3l9w)\n\n本教程将深入探讨 CSS 网格布局，并探索几乎所有的属性和功能。读完之后，你将能够用这种出色的 CSS 附加功能去处理任何一种布局。\n\n[Vue最全知识点，面试必备（基础到进阶，覆盖vue3.0，持续更新整理，欢迎补充讨论）](https://mp.weixin.qq.com/s/FHwkJQBTZaVXbqLERoBWkg)\n\n* 说说你对MVVM的理解\n* Vue2.x响应式数据/双向绑定原理\n* Proxy 与 Object.defineProperty 优劣对比\n...\n\n[大规格文件的上传优化](https://mp.weixin.qq.com/s/0oVi1qYNe0QNiPmThco2qg)\n\n在开发过程中，收到这样一个问题反馈，在网站上传 100 MB 以上的文件经常失败，重试也要等老半天，这就难为需要上传大规格文件的用户了。那么应该怎么做才能快速上传，就算失败了再次发送也能从上次中断的地方继续上传呢？下文为你揭晓答案~\n\n[Nginx 负载均衡和缓存服务实战](https://mp.weixin.qq.com/s/HWA9b3Mg6ShVaYCuNIsWAA)\n\n文章详细介绍了Nginx基础配置、使用。实际场景问题如何解决，以及如何合理搭建负载均衡以及缓存服务。同时在最后总结了一些常见问题以及解决方案。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。","tags":["精选"]},{"title":"第23期 10个案例让你彻底理解React hooks的渲染逻辑 & 花椒前端TypeScript实践总结 & Vue3.0来了，看看尤大大画的重点","url":"/hotlink23/","content":"\n[花椒前端TypeScript实践总结](https://mp.weixin.qq.com/s/C8JXI4O3tMzg6_HvDtUQ4Q)\n\n你是否经常在文章中见到 “你还没有用TypeScript么，都2020年了！” 这样的标语？今天我们就来探究一下TypeScript的优缺点。\n\n[是什么尤大选择放弃Webpack？——vite 原理解析](https://mp.weixin.qq.com/s/NgpHG6W8ts99oTVy8MdTSg)\n\n前两天尤大在Vue 3.0 beta直播中提到了一个vite的工具，其描述是：针对Vue单页面组件的无打包开发服务器，可以直接在浏览器运行请求的vue文件，对其原理比较感兴趣，因此体验并写下了本文，主要包括vite实现原理分析和一些思考。\n\n[Vue3.0来了，看看尤大大画的重点](https://mp.weixin.qq.com/s/zjuHn6uaWivtsLsK5Ima8A)\n\n众所周知，前端的技术一直更新的特别快，特别是框架这块。4月21号晚，Vue作者尤雨溪在B站直播分享了 Vue.js 3.0 Beta 最新进展，想必大家都有去观摩吧？那我们今天一起来回顾下尤大大的分享:\n\n[10个案例让你彻底理解React hooks的渲染逻辑](https://mp.weixin.qq.com/s/-Ao9DATp2B3Qgefbc1XN0g)\n\n正式开始，今天要写什么呢，原本我对react原理非常清楚，自己写过简单的react，带diff算法和异步更新队列的，但是对hooks源码一知半解，于是就要深究他的性能相关问题了   - 重复渲染的逻辑\n\n[Node.js AsyncHooks 与异步回调上下文](https://mp.weixin.qq.com/s/1NRJlExm75V8NjhN6Ob7Gg)\n\n我们都知道，Nodejs 最显著特点是单进程、异步、事件驱动。每当我们的代码碰到异步调用时，需要传入一个回调函数，等待异步调用结束时再被执行。一个典型的处理用户登录流程如下：\n\n[从 0 开始发布一个无依赖、高质量的 npm 包](https://mp.weixin.qq.com/s/PUZ1TBbmd7BGt-UL-4gy8A)\n\n没有发布过npm包的同学，可能会对NPM对开发有一种蜜汁敬畏，觉得这是一个很高大上的东西。甚至有次面试，面试官问我有没有发过npm包，当时只用过还没写过，我想应该挺难的，就小声说了没有，然后就让我回去了o(╯□╰)o。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"第22期 Recoil-Facebook官方React状态管理器 & Facebook前端技术栈重构分享 & 我在阿里是怎么工作的，写在阿里入职一周年","url":"/hotlink22/","content":"\n[Recoil-Facebook官方React状态管理器](https://mp.weixin.qq.com/s/P6dBlR5OTq1Cx2RHtEuHzQ)\n\n说到状态管理器，轮子满天飞。在 Class 时代，redux 与 mobx 几乎占据了全部市场，几乎没有没用过 redux 的同学。随着 Hooks 的诞生，新的一批轮子应运而生，其中有代表性的有 unstated-next、constate 等等。\n\n最近，facebook 官方出了一个状态管理器解决方案 Recoil[1]，我们来体验一下。\n\n[蚂蚁金服是如何提高移动端体验的？](https://mp.weixin.qq.com/s/2-j7ykMNn4IdYdjlcKDEHQ)\n\n体验是一个很庞大的话题，有很多方面会影响产品的体验，如性能、UI、交互以及人性化的功能等等，本文抛砖引玉，只从技术层面的某几个方面聊聊移动端的体验优化，主要以 Android 为切入点，IOS 大部分优化方向与 Android 类似。考虑到市面上绝大多数 APP 都是 Native+H5 相结合的应用，且本人项目中也大量使用 H5 页面，因此将从 Native 端和 H5 端分别总结如何优化体验。\n\n[我在阿里是怎么工作的，写在阿里入职一周年](https://mp.weixin.qq.com/s/EJKIxxPyy-_-YeV7b239xQ)\n\n2019年初，笔者从腾讯跳槽到阿里。新的公司新的氛围，坦白说，阿里新岗位的工作强度大于之前在腾讯的岗位。我入职后不久后就迫于试用期答辩项目的压力，开始周末加班，后来又因为自己懒散，中断了坚持了一年多的博客更新。经过了一年多的阿里熏陶，我优化调整了自己部分的工作方法论并取得了不错的效果——重新找回了有节奏的工作生活。在这个过程中，总结了5条高效工作的经验，在这里分享给大家，希望能对大家有所帮助。\n\n[Facebook前端技术栈重构分享](https://mp.weixin.qq.com/s/QyfcokJAdZr6fYR1L4Xm6g)\n\n当我们考虑如何构建一个新的网络应用—一个为现代浏览器设计的、具有用户对Facebook（我们已知的）所有期望的功能，我们现有的技术栈无法支持我们所需要的类似于桌面应用的感觉和性能。完全重写是非常罕见的，但在这种情况下，由于过去十年来Web技术发生了很多变化，我们知道这是我们实现性能和未来可持续发展目标的唯一途径。今天，我们就分享一下我们在重构Facebook.com时的经验教训，使用React（一种用于构建用户界面的声明式JavaScript库）和Relay（React的GraphQL客户端）来重构Facebook.com。\n\n[揭秘webpack插件工作流程和原理](https://mp.weixin.qq.com/s/LI-SkBoPA94Ply6Qes92PA)\n\n通过插件我们可以扩展webpack，在合适的时机通过Webpack提供的 API 改变输出结果，使webpack可以执行更广泛的任务，拥有更强的构建能力。 本文将尝试探索 webpack 插件的工作流程，进而去揭秘它的工作原理。同时需要你对webpack底层和构建流程的一些东西有一定的了解。\n\n[深度精读:浏览器渲染原理](https://mp.weixin.qq.com/s/qPxDYVpzmazZaSIcaVWMpQ)\n\n本文从浏览器角度来告诉你，URL后输入后按回车，浏览器内部究竟发生了什么，读完本文后，你将了解到：\n\n* 浏览器内有哪些进程，这些进程都有些什么作用\n* 浏览器地址输入URL后，内部的进程、线程都做了哪些事\n* 我们与浏览器交互时，内部进程是怎么处理这些交互事件的\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"模拟实现new运算符功能","url":"/js-new/","content":"\nnew 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一\n\n示例：\n```javascript\nfunction Wechat() {\n  this.name = 'fedaily'\n}\nWechat.prototype.getName = function() {\n  return this.name\n}\n\nconst wechat = new Wechat()\n// wechat.name === fedaily\n// wechat.getName() === fedaily\n```\n\n我们可以看到，实例可以访问到构造函数的属性以及原型对象上的属性。\n\n所以我们可以模拟一下：\n```javascript\nfunction newFactory() {\n  var obj = new Object(),\n  Constructor = [].shift.call(arguments);\n  obj.__proto__ = Constructor.prototype;\n  // 处理构造函数有返回值的情况\n  // 返回值如果是一个object则直接返回，否则返回obj\n  var ret = Constructor.apply(obj, arguments);\n  return typeof ret === 'object' ? ret : obj;\n};\n```\n","tags":["JavaScript"]},{"title":"第21期 在TS中如何减少重复代码 & 优秀网站必须关注的健康指标 & 了不起的 Deno 入门教程","url":"/hotlink21/","content":"\n[Vue 的计算属性如何实现缓存？（原理深入揭秘）](https://mp.weixin.qq.com/s/J1zznDfwTAHvAbTNgftJRA)\n\n很多人提起 Vue 中的 computed，第一反应就是计算属性会缓存，那么它到底是怎么缓存的呢？缓存的到底是什么，什么时候缓存会失效，相信还是有很多人对此很模糊。\n本文以 Vue 2.6.11 版本为基础，就深入原理，带你来看看所谓的缓存到底是什么样的。\n\n[优秀网站必须关注的健康指标 | Web Vitals 闪亮登场](https://mp.weixin.qq.com/s/BSlOnrmDLWhzpCWAuTOulw)\n\n优化用户体验质量是所有网站取得长期成功的关键。通过与数百万网络开发者和网站所有者的持续交流和协作，我们在 Google 开发了许多实用指标和工具，以帮助企业所有者、市场营销人员和开发者发掘改善用户体验的机会。然而，丰富多样的指标和工具也给许多人带来了各种优先级、明晰度和一致性方面的挑战。\n\n今天，我们为各位介绍一项名为 Web Vitals 的新计划，此计划的发起方为 Google，旨在提供各种质量信号的统一指南，我们相信这些质量信号对提供出色的网络用户体验至关重要。\n\n[在TS中如何减少重复代码](https://mp.weixin.qq.com/s/I7ciHCgFjLFv_rHQn_dY_A)\n\n相信有些读者已经听说过 DRY 原则，DRY 的全称是 —— Don't Repeat Yourself ，是指编程过程中不写重复代码，将能够公共的部分抽象出来，封装成工具类或者用抽象类来抽象公共的东西，从而降低代码的耦合性，这样不仅提高代码的灵活性、健壮性以及可读性，也方便后期的维护。\n\n接下来，本文将介绍在 TypeScript 项目开发过程中，如何借鉴 DRY 原则尽量减少重复代码。\n\n[了不起的 Deno 入门教程](https://mp.weixin.qq.com/s/9R--wREYRW2M7GA6zn9Hdg)\n\nDeno 是一个 JavaScript/TypeScript 的运行时，默认使用安全环境执行代码，有着卓越的开发体验。\n\n[Node.js 中的 stream 模块详解](https://mp.weixin.qq.com/s/N6U-Lj7ts2aLiv4KC22DAw)\n\n流的英文stream，流（Stream）是一个抽象的数据接口，Node.js中很多对象都实现了流，流是EventEmitter对象的一个实例，总之它是会冒数据（以 Buffer 为单位），或者能够吸收数据的东西，它的本质就是让数据流动起来。\n\n[理解 JavaScript 内存模型，就靠这几张图了！](https://mp.weixin.qq.com/s/bLnjDg5lbH7CVhvXOz2Gkw)\n\n作为程序员，声明变量、初始化变量、给变量重新赋值，这些是我们的日常工作。\n\n但是，这么做的时候实际上发生了什么？JavaScript 是如何在内部处理这些基本功能的？更重要的是，作为程序员，理解 JavaScript 的底层细节对我们有什么好处？\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n"},{"title":"彻底弄清js继承的几种实现方式","url":"/js-inheritance/","content":"\njs有几种经典的继承方式。比如原型链继承、构造函数继承、组合继承、寄生组合继承、ES6继承。让我们一一分析并实现。同时了解每种方案的优缺点。\n\n其实js的继承本质上是通过原型链机制实现的扩展。不管是哪种继承方式，都是通过操作父类原型链和子类原型链形成关联关系实现的。只是不同实现中需要考虑不同的问题。在实际项目开发中，建议尽可能使用ES6的class extends实现。\n其他实现方式主要是理解背后的原理和思想。\n\n### 原型链继承\n原型链继承通过修改子类的原型为父类的实例，从而实现子类可以访问到父类构造函数以及原型上的属性或者方法。\n\n让我们来实现一下：\n```javascript\nfunction Parent() {\n  this.name = 'fedaily'\n}\n\nParent.prototype.getName = function() {\n  return this.name;\n}\n\nfunction Child() {}\n\n// 这里也可以直接写出Child.prototype = Parent.prototype\n// 但是这样就不能访问到父类的构造函数的属性了，即this.name\nChild.prototype = new Parent()\n\nvar child = new Child()\nchild.getName() // fedaily\n```\n\n#### 优点\n实现逻辑简单\n\n#### 缺点\n父类构造函数中的引用类型（比如对象/数组），会被所有子类实例共享。其中一个子类实例进行修改，会导致所有其他子类实例的这个值都会改变\n\n### 构造函数继承\n构造函数继承其实就是通过修改父类构造函数this实现的继承。我们在子类构造函数中执行父类构造函数，同时修改父类构造函数的this为子类的this。\n\n我们直接看如何实现：\n```javascript\nfunction Parent() {\n  this.name = ['fedaily']\n}\n\nfunction Child() {\n  Parent.call(this)\n}\n\nvar child = new Child()\nchild.name.push('fe')\n\nvar child2 = new Child() // child2.name === ['fedaily']\n```\n\n#### 优点\n解决了原型链继承中构造函数引用类型共享的问题，同时可以向构造函数传参（通过call传参）\n\n#### 缺点\n所有方法都定义在构造函数中，每次都需要重新创建（对比原型链继承的方式，方法直接写在原型上，子类创建时不需要重新创建方法）\n\n### 组合继承\n同时结合原型链继承、构造函数继承就是组合继承了。\n```javascript\nfunction Parent() {\n  this.name = 'fedaily'\n}\n\nParent.prototype.getName = function() {\n  return this.name\n}\n\nfunction Child() {\n  Parent.call(this)\n  this.topic = 'fe'\n}\n\nChild.prototype = new Parent()\n// 需要重新设置子类的constructor，Child.prototype = new Parent()相当于子类的原型对象完全被覆盖了\nChild.prototype.constructor = Child\n```\n\n#### 优点\n同时解决了构造函数引用类型的问题，同时避免了方法会被创建多次的问题\n\n#### 缺点\n父类构造函数被调用了两次。同时子类实例以及子类原型对象上都会存在name属性。虽然根据原型链机制，并不会访问到原型对象上的同名属性，但总归是不美。\n\n### 寄生组合继承\n寄生组合继承其实就是在组合继承的基础上，解决了父类构造函数调用两次的问题。我们来看下如何解决的：\n```javascript\nfunction Parent() {\n  this.name = 'fedaily'\n}\n\nParent.prototype.getName = function() {\n  return this.name\n}\n\nfunction Child() {\n  Parent.call(this)\n  this.topic = 'fe'\n}\n\n// 仔细看这个函数的实现\ninherit(Child, Parent)\n```\n\n```javascript\nfunction inherit(child, parent) {\n  var prototype = object(parent.prototype)\n  prototype.constructor = child\n  child.prototype = prototype\n}\n\n// 这个函数的作用可以理解为复制了一份父类的原型对象\n// 如果直接将子类的原型对象赋值为父类原型对象\n// 那么修改子类原型对象其实就相当于修改了父类的原型对象\nfunction object(o) {\n  function F() {}\n  F.prototype = o;\n  return new F();\n}\n```\n\n#### 优点\n这种方式就解决了组合继承中的构造函数调用两次，构造函数引用类型共享，以及原型对象上存在多余属性的问题。是推荐的最合理实现方式（排除ES6的class extends继承哈哈哈）。\n\n#### 缺点\n没有啥特别的缺点\n\n### ES6继承\nES6提供了class语法糖，同时提供了extends用于实现类的继承。这也是项目开发中推荐使用的方式。\n\n使用class继承很简单，也很直观：\n```javascript\nclass Parent {\n  constructor() {\n    this.name = 'fedaily'\n  }\n\n  getName() {\n    return this.name\n  }\n}\n\nclass Child extends Parent {\n  constructor() {\n    // 这里很重要，如果在this.topic = 'fe'后面调用，会导致this为undefined，具体原因可以详细了解ES6的class相关内容，这里不展开说明\n    super()\n    this.topic = 'fe'\n  }\n}\n\nconst child = new Child()\nchild.getName() // fedaily\n```\n","tags":["JavaScript"]},{"title":"interface 和 type aliases 区别","url":"/ts-interface-vs-type-aliases/","content":"\n[TypeScript interface vs type aliases](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases)\n\n在大多数情况下，interface和类型别名并没有太大的区别。但是，它们有一些微妙的区别。\n\n其中一个区别就是interface会创建一个新的类型名称，并且可以在任何地方使用。但是type没有，它只是一个引用，并没有创建一个新的类型实例。\n\n看下面这个例子，当我们鼠标hover到interfaced的时候，编辑器会提示当前函数返回一个Interface。而当我们hover到aliased的时候，返回的是一个{ num: number }对象。\n```javascript\ntype Alias = { num: number };\ninterface Interface {\n  num: number;\n}\ndeclare function aliased(arg: Alias): Alias;\ndeclare function interfaced(arg: Interface): Interface;\n```\n\n在老版本的typescript中，类型别名是不支持extended或者implemented（也不支持从其他类型别名extend/implement）\n\n在2.7版本后，类型别名可以通过交叉类型实现extend。例如`type Cat = Animal & { purrs: true }`\n\n根据软件的[开闭原则](https://en.wikipedia.org/wiki/Open/closed_principle), 你应该尽可能的使用interface代替type alias。\n\n从另一方面说，如果你不能使用interface表达你的类型，需要使用到联合类型或者元组，那么就可以使用type alias。\n\n### 英文原文：\nAs we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.\n\nOne difference is that interfaces create a new name that is used everywhere. Type aliases don’t create a new name — for instance, error messages won’t use the alias name. In the code below, hovering over interfaced in an editor will show that it returns an Interface, but will show that aliased returns object literal type.\n```javascript\ntype Alias = { num: number };\ninterface Interface {\n  num: number;\n}\ndeclare function aliased(arg: Alias): Alias;\ndeclare function interfaced(arg: Interface): Interface;\n```\n\nIn older versions of TypeScript, type aliases couldn’t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. type Cat = Animal & { purrs: true }.\n\nBecause [an ideal property of software is being open to extension](https://en.wikipedia.org/wiki/Open/closed_principle), you should always use an interface over a type alias if possible.\n\nOn the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.\n","tags":["TypeScript"]},{"title":"斐波那契数列","url":"/fibnacci/","content":"\n使用数组结构实现一个非递归的斐波那契数列\n\n```javascript\nconst fibnacci = (n) => {\n  if (n === 0) {\n    return 0;\n  }\n  let a = 0;\n  let b = 1;\n  for (let i = 1; i <= n; i += 1) {\n    [a, b] = [a, a + b];\n  }\n  return b;\n}\n```\n","tags":["算法"]},{"title":"为什么我们要写 super(props) ？","url":"/why-super-props/","content":"\n>转载自https://overreacted.io/zh-hans/why-do-we-write-super-props/\n\n据说 Hooks 势头正盛，不过我还是想略带调侃地从 class 的有趣之处开始这篇博客。可还行？\n\n这些梗对于使用 React 输出产品并不重要，但如果你想深入的了解它们的运作原理，它们会非常的有用。\n\n首先，在这一生中，`super(props)` 出现在我代码里的次数比我知道的还要多：\n```javascript\nclass Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}\n```\n\n当然了，我们可以通过 `class fields proposal` 来省略这个声明：\n```javascript\nclass Checkbox extends React.Component {\n  state = { isOn: true };\n  // ...\n}\n```\n\n早在 2015 年 React 0.13 已经计划支持 。在当时，声明 `constructor` 和调用 `super(props)` 一直被视作暂时的解决方案，直到有合适的类字段声明形式。\n\n但在此之前，我们先回到 ES2015 风格的代码：\n```javascript\nclass Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}\n```\n\n为什么我们要调用 super，我们可以不这么做吗？那么在我们调用它时不传入 props，又会发生什么呢？会有其他的缺省参数吗？接来下我们就解开这一系列谜题。\n\n在 JavaScript 中，super 指的是父类（即超类）的构造函数。（在我们的例子中，它指向了 React.Component 的实现。）\n\n值得注意的是，在调用父类的构造函数之前，你是不能在 constructor 中使用 this 关键字的。JavaScript 不允许这个行为。\n```javascript\nclass Checkbox extends React.Component {\n  constructor(props) {\n    // 🔴  还不能使用 `this`\n    super(props);\n    // ✅  现在可以了\n    this.state = { isOn: true };\n  }\n  // ...\n}\n```\n\nJavaScript 有足够合理的动机来强制你在接触 this 之前执行父类构造函数。考虑考虑一些类层次结构的东西：\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass PolitePerson extends Person {\n  constructor(name) {\n    this.greetColleagues(); // 🔴  这是禁止的，往后见原因\n    super(name);\n  }\n  greetColleagues() {\n    alert('Good morning folks!');\n  }\n}\n```\n\n试想一下，在调用 super 之前使用 this 不被禁止的情况下，一个月后，我们可能在 `greetColleagues` 打印的消息中使用了 person 的 name 属性：\n```javascript\ngreetColleagues() {\n  alert('Good morning folks!');\n  alert('My name is ' + this.name + ', nice to meet you!');\n}\n```\n\n但是我们并未想起 `this.greetColleagues` 在 super() 给 this.name 赋值前就已经执行。this.name 此时甚至尚未定义。可以看到，这样的代码难以往下推敲。\n\n为了避免落入这个陷阱，JavaScript 强制你在使用 this 之前先行调用 super。让父类来完成这件事情！：\n```javascript\nconstructor(props) {\n  super(props);\n  // ✅ 能使用 `this` 了\n  this.state = { isOn: true };\n}\n```\n\n这里留下了另一个问题：为什么要传入 props ？\n\n你或许会想到，为了让 React.Component 构造函数能够初始化 this.props，将 props 传入 super 是必须的：\n```javascript\n// React 內部\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n```\n\n这几乎就是真相了 — 确然，它是 这样做 的。\n\n但有些扑朔迷离的是，即便你调用 super() 的时候没有传入 props，你依然能够在 render 函数或其他方法中访问到 this.props。（如果你质疑这个机制，尝试一下即可）\n\n那么这是怎么做到的呢？事实证明，React 在调用构造函数后也立即将 props 赋值到了实例上：**\n```javascript\n// React 内部\nconst instance = new YourComponent(props);\ninstance.props = props;\n```\n\n因此即便你忘记了将 props 传给 super()，React 也仍然会在之后将它定义到实例上。这么做是有原因的。\n\n当 React 增加了对类的支持时，不仅仅是为了服务于 ES6。其目标是尽可能广泛地支持类抽象。当时我们 不清楚 `ClojureScript，CoffeeScript，ES6，Fable，Scala.js，TypeScript` 等解決方案是如何成功的实践组件定义的。因而 React 刻意地没有显式要求调用 super() —— 即便 ES6 自身就包含这个机制。\n\n这意味着你能够用 super() 代替 super(props) 吗？\n\n最好不要，毕竟这样写在逻辑上并不明确确然，React 会在构造函数执行完毕之后给 this.props 赋值。但如此为之会使得 this.props 在 super 调用一直到构造函数结束期间值为 undefined。\n```javascript\n// React 內部\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n// 你的程式碼內部\nclass Button extends React.Component {\n  constructor(props) {\n    super(); // 😬 我们忘了传入 props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // 😬 未定义\n  }\n  // ...\n}\n```\n\n如果在构造函数中调用了其他的内部方法，那么一旦出错这会使得调试过程阻力更大。这就是我建议开发者一定执行 super(props) 的原因，即使理论上这并非必要：\n```javascript\nclass Button extends React.Component {\n  constructor(props) {\n    super(props); // ✅ 传入 props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // ✅ {}\n  }\n  // ...\n}\n```\n\n确保了 this.props 在构造函数执行完毕之前已被赋值。\n\n最后，还有一点是 React 爱好者长期以来的好奇之处。\n\n你会发现当你在类中使用 Context API （无论是旧版的 contextTypes 或是在 React 16.6 更新的新版 contextTypes）的时候，context 是作为第二个参数传入构造函数的。\n\n那么为什么我们不能转而写成 `super(props, context)` 呢？我们当然可以，但 context 的使用频率较低，因而并没有掘这个坑。\n\nclass fields proposal 出台后，这些坑大部分都会自然地消失在没有显示的定义构造函数的情况下，以上的属性都会被自动地初始化。这使得像 state = {} 这类表达式能够在需要的情况下引用 this.props 和 this.context 的内容。\n\n然而，有了 Hooks 以后，我们几乎就不需要 super 和 this 了。但那就是另一个下午的茶点了。\n","tags":["转载","React"]},{"title":"第19期 彻底搞懂React源码调度原理（Concurrent模式）& HTTP/3原理与实践","url":"/hotlink19/","content":"\n[HTTP/3原理与实践](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651236564&idx=1&sn=4cfbf59ed50cc45d889613e5b19292bd&scene=21#wechat_redirect)\n\n2015 年 HTTP/2 标准发表后，大多数主流浏览器也于当年年底支持该标准。此后，凭借着多路复用、头部压缩、服务器推送等优势，HTTP/2 得到了越来越多开发者的青睐。不知不觉的 HTTP 已经发展到了第三代，鹅厂也紧跟技术潮流，很多项目也在逐渐使用 HTTP/3。本文基于 QQ兴趣部落接入 HTTP/3 的实践，聊一聊 HTTP/3 的原理以及业务接入的方式。\n\n[如何回答好这个高频面试题：CommonJS和ES6模块的区别？](https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485426&idx=1&sn=1caa7a95942fc573ae15b004010522cd&scene=21#wechat_redirect)\n\n通过阅读本篇文章你可以学习到：\n原始模拟模块的一些写法\nCommonJS规范\nAMD规范\nCMD规范\nAMD和CMD的区别\nES6 Modules规范\nCommonJS与ES6 Modules规范的区别\n\n[那些年与面试官交手过的HTTP问题](https://mp.weixin.qq.com/s?__biz=MzA4ODUzNTE2Nw==&mid=2451047001&idx=1&sn=834dd557bfd7a17474160e1b9dabaa61&scene=21#wechat_redirect)\n\n从淡黄的长裙和蓬松的头发我察觉到，面前坐着的这位女面试官属实是有点东西。我的自我介绍也变得声情并茂起来。Skr~~~ 在此期间，小姐姐面无改色的看着我的简历。不过无所谓，这些都不重要。\n\n[彻底搞懂React源码调度原理（Concurrent模式）](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651236611&idx=1&sn=c908931b15b7981e0c52e972a9e6ed07&scene=21#wechat_redirect)\n\n最早之前，React还没有用fiber重写，那个时候对React调度模块就有好奇。而现在的调度模块对于之前没研究过它的我来说更是带有一层神秘的色彩，色彩中朦胧浮现出两个字：“困难”。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"第18期 手把手教你实现「京喜工厂」的CSS动画效果 & 前端网红框架的插件机制axios、koa、redux、vuex","url":"/hotlink18/","content":"\n[手把手教你实现「京喜工厂」的CSS动画效果](https://mp.weixin.qq.com/s?__biz=MzI5NjIzNjA1Nw==&mid=2247484579&idx=1&sn=74adcdc4708ebd64b99fcddeaa40982a&scene=21#wechat_redirect)\n\n今年Q1（2020年第一季度）参与了京喜事业部「京喜工厂」业务的前端开发。用户可以通过「京喜工厂」参与口罩、抽纸、大米等商品的“在线生产”，既能趣味造物，又能免费领奖品。目前可以通过「京喜」小程序首页访问该活动。\n活动在上线后不久，PV 达到千万的量级，引人注目。有不少前端同学好奇里面涉及到的动画实现，文本应运而生。\n\n[如何设计大型前端团队基建路线](https://mp.weixin.qq.com/s?__biz=MjM5MDc4MzgxNA==&mid=2458454613&idx=1&sn=5024a9cc96b960c88cfd9bd79129ecb6&scene=21#wechat_redirect)\n\n大家下午好，我今天要分享的主题叫【大型前端团队的基建设计整合之路】，主要会跟大家分享下我们团队这么多年积累下来的前端基础设施相关方面的一些成果和心得。\n\n[京喜前端的自动化测试之路](https://mp.weixin.qq.com/s?__biz=MzI2NTk2NzUxNg==&mid=2247485048&idx=1&sn=59a989ce925c2f7e3c247e2a64a104bb&scene=21#wechat_redirect)\n\n京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。\n\n[重温基础：正则表达式](https://mp.weixin.qq.com/s?__biz=MjM5MDc4MzgxNA==&mid=2458454613&idx=4&sn=edfd5b329438eea9599e0c82e7293a5a&scene=21#wechat_redirect)\n\n本章节复习的是JS中的正则表达式，JS中用来匹配字符串的强大工具。\n\n[深入理解 动态 Import 和 顶层 await](https://mp.weixin.qq.com/s?__biz=MzIwNTc4OTU2NA==&mid=2247485052&idx=1&sn=e8ebc37db33fb4fe0d9a849ff3ffa267&scene=21#wechat_redirect)\n\n随着 ES6 的发布，JavaScript 语法也越来越趋于成熟，新的提案也在不断地提出。\nECMA 提案一共有四个阶段，处于 Stage3 的都需要我们持续关注，以后很可能就会被纳入新标准中。\n今天主要来深入讲解一下动态 import 和 Top-level await。\n\n[TypeScript 3.9正式发布！平均编译时长从26秒缩短至10秒](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247494688&idx=1&sn=9f924231ad2edb07b9d56027f03d3a86&scene=21#wechat_redirect)\n\n有些朋友可能对 TypeScript 还不太熟悉，这是一种以 JavaScript 为基础开发的语言，新增 type 声明与注释等多种语法。TypeScript 编译器能够使用这些语法对代码进行 type 检查，而后输出能够适配多种不同运行时、且清晰可读的 JavaScript 代码。\n\n[前端网红框架的插件机制全梳理（axios、koa、redux、vuex）](https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485368&idx=1&sn=3118fef9dd9fadca66f7e7d2c317026c&scene=21#wechat_redirect)\n\n前端中的库很多，开发这些库的作者会尽可能的覆盖到大家在业务中千奇百怪的需求，但是总有无法预料到的，所以优秀的库就需要提供一种机制，让开发者可以干预插件中间的一些环节，从而完成自己的一些需求。\n本文将从koa、axios、vuex和redux的实现来教你怎么编写属于自己的插件机制。\n\n[花式解说防抖函数debounce的实现](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650591878&idx=1&sn=28e8021b44d92f5dcd534aa4d4ebcf51&scene=21#wechat_redirect)\n\n歪式絮叨：原本打算只用一篇文章总结下防抖和节流的，但是写着写着发现挺有意思的。所以准备会分成 3-4 篇来写了，单独的防抖和节流的实现，然后在去分享一下知名库的源码。今天先跟歪马一起看看防抖的实现吧。其他内容敬请期待~！\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"如何模拟实现一个call、apply、bind函数","url":"/call-applay-bind/","content":"\n首先强烈推荐这位大佬的文章，写的相当棒，后续讨论内容的也是你来我往，分析的很透彻。\n[JavaScript深入之call和apply的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)\n[JavaScript深入之bind的模拟实现](https://github.com/mqyqingfeng/Blog/issues/12)\n\ncall, apply, bind这三个方法都可以改变函数内部this指向。区别是call, apply是立即指向该函数，而bind是返回一个新的函数，用于下次调用。\n\n其中，call和apply的区别是传递函数参数的方式不同，call是一个一个传入，例如call(this, arg1, arg2, arg3)这样。但是apply是通过一个数组传递，比如apply(this, [arg1, arg2, arg3])。\n\n### call模拟实现\n\n首先我们实现绑定this功能。\n```\n// 比如我们有一个foo函数\nfunction getName() {\n  return this.name;\n}\n\n// 还有一个wechat对象\nconst wechat = { name: 'fedaily' };\n\n// 我们希望实现\ngetName.call(wechat); // fedaily\n```\n\n那么在call内部如何设计能够实现这个功能呢，我们可以联想到将`getName`方法变成`wechat`对象里的一个方法，然后通过`wechat.getName()`，是不是就可以实现这个效果了。\n\n我们来实践一下：\n```\nFunction.prototype.call = function (context) {\n  context.fn = this;\n  context.fn();\n  delete context.fn;\n}\n```\n\n以`wechat`和`getName`这个为例，这里的this即getName，context即wechat。\n我们将`getName`赋值给`wechat`对象的`fn`熟悉，然后通过`wechat`对象调用，最后删除这个fn属性。（实际中我们肯定不能用fn这个名字，避免和对象原本重复，我们可以用Symbol实现）\n\n然后我们绑定this的功能就实现。还有传递参数，这个也好办。\n```\nFunction.prototype.call = function () {\n  const [ctx, ...args] = arguments;\n  ctx.fn = this;\n  ctx.fn(...args);\n  delete ctx.fn;\n}\n// 这里其实用了ES6的语法，但是主要为了更好的说明整个实现过程，理解原理就好\n```\n\n这里通过`arguments`对象去获取传进来的参数以及`this`。\n\n然后考虑到函数可能是有返回值的，所以`ctx.fn()`的执行结果也需要返回。同时this可能为null，那么我们需要将this指向window。\n\n所以我们再来调整一下：\n```\nFunction.prototype.call = function () {\n  const [ctx, ...args] = arguments;\n  ctx.fn = this || window;\n  const result = ctx.fn(...args);\n  delete ctx.fn;\n  return result;\n}\n```\n\n这样，我们就模拟实现了一个call方法。\n\n### apply模拟实现\n\n接上文，我们再来实现一个apply就很容易了。我们直接上代码：\n```\nFunction.prototype.apply = function () {\n  const [ctx, args] = arguments; // args区别\n  ctx.fn = this || window;\n  const result = ctx.fn(...args);\n  delete ctx.fn;\n  return result;\n}\n```\n\n### bind模拟实现\n\nbind会返回一个新函数，新函数执行时的this是bind方法的第一个参数。\n\n根据这些特征，我们可以想到使用apply帮助实现。还是以上面的`getName`函数为例。\n```\nFunction.prototype.bind = function () {\n  const [ctx, ...args] = arguments;\n  const self = this; // 这里的this即getName函数\n  return function () {\n    self.applay(ctx, args);\n  }\n}\n```\n\n这样，绑定this的功能我们就实现了。然后bind其实是可以传递参数的，bind返回的函数调用的时候也是可以再传递参数的，同时调用bind的方法可能是有返回值的，所以我们处理一下\n```\nFunction.prototype.bind = function () {\n  const [ctx, ...args] = arguments;\n  const self = this; // 这里的this即getName函数\n  return function () {\n    // 这下面的arguments其实是调用bind返回的函数，当这个函数调用时传递的参数\n    // 同时返回函数执行结果\n    return self.applay(ctx, args.concat(arguments));\n  }\n}\n```\n\nbind函数还有一个特性，就是bind返回的函数是可以作为构造函数的，当它作为构造函数时，它之前绑定的this会被忽略。\n为了保证bind返回的函数能够继承到调用函数的原型(即getName的原型)。所以我们需要修改bind返回函数的原型为this的原型(即getName的原型)。\n\n我们再来尝试一下：\n```\nFunction.prototype.bind = function () {\n  const [ctx, args] = arguments;\n  const self = this;\n  const fBond = function () {\n    // 注意这里的this不是getName了，而是调用bind之后方法的this\n    // const newGetName = getName.bind(this)\n    // const n = new newGetName()\n    // this就是n\n    return self.apply(this instanceof fBond ? this : ctx, args.concat(arguments));\n  }\n  fBond.prototype = self.prototype;\n  return fBond;\n}\n```\n\n然后为了不会修改原来函数的原型，即getName的原型。我们可以通过一个中间函数来继承。\n\n```\nFunction.prototype.bind = function () {\n  if (typeof this !== \"function\") {\n    throw new Error(\"Must be function to call bind\");\n  }\n\n  const [ctx, args] = arguments;\n  const self = this;\n  var fNOP = function () {};\n  const fBond = function () {\n    return self.apply(this instanceof fBond ? this : ctx, args.concat(arguments));\n  }\n  // 这里将self的原型赋值给来fNOP，后面fBond的原型赋值为new fNOP()，这样就和self的原型断开了\n  // 后面再修改fBond的原型也不会影响到self，即getName.prototype\n  fNOP.prototype = self.prototype;\n  fBond.prototype = new fNOP();\n  return fBond;\n}\n```\n\n这样，我们就实现了一个比较完整的bind方法了。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["JavaScript"]},{"title":"第17期 Vue3.0之前你必须知道的TypeScript实战技巧 & 移动端开发的兼容适配与性能优化干货分享","url":"/hotlink17/","content":"\n[关于Node.js中内存管理的思考与实践](https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485359&idx=2&sn=01e110c4d6f56b1415125eccc19524c2&scene=21#wechat_redirect)\n\n随着Node的发展，JavaScript的运行已经不再局限于运行在浏览器中了，Node在服务端的应用使得越来越多的问题也显现出来。对于刚接触JavaScript的开发者来说，基本上很少会想到内存分配或者内存泄露的问题，为了跟上潮流，就讲解一下Node是如何合理高效地使用内存，防止内存泄漏。\n\n[Vue3.0之前你必须知道的TypeScript实战技巧](https://mp.weixin.qq.com/s?__biz=Mzg5NDEyMzA2NQ==&mid=2247485138&idx=1&sn=6efe935ee8578a5b71ad64d2300179c2&scene=21#wechat_redirect)\n\n很多人对TypeScript的使用还停留在基本操作上,其实 TypeScript 的特性非常强大,我们利用好这些特性可以有效地提高代码质量、加速开发效率，今天就介绍 9 个非常实用的 TypeScript 技巧或者特性。\n\n[移动端开发的兼容适配与性能优化干货分享](https://mp.weixin.qq.com/s?__biz=MzI5MjUxNjA4Mw==&mid=2247486891&idx=2&sn=90a069d25967dfcf8212fa8ab3b74883&scene=21#wechat_redirect)\n\n本文是内部的一次分享沉淀，偏向基础但是涉及了一些有意思的细节，文笔有限，才疏学浅，文中若有不正之处，万望告知。\n\n[大厂面试过程复盘(微信/阿里/头条,附答案篇)](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826916&idx=1&sn=f2c0b39cafde9bf73d0bc78052b0e16b&scene=21#wechat_redirect)\n\n本人前端，3年经验，由于个人的原因，决定跳槽，于是大概3月开始找工作，总历时大概2个月，面试了微信/阿里/头条，三家都拿到了offer，来分享一下面经。\n\n[Node使用火焰图优化CPU爆涨](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651236559&idx=1&sn=63a1f3bc17e47f4c1fc96ba1a56ae49c&scene=21#wechat_redirect)\n\n话不多说，先上图，这是得到App静态资源更新服务的CPU使用率监控，可以看到7月2号到7月3号后，cpu使用率发生了爆涨，在八点的早高峰和下午六点的晚高峰，几乎可以把cpu打满。发现问题当机立断，升级配置将2核4g升级至4核8g，先保证服务稳定，我们再继续查问题。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"第16期 从零实现webpack热更新 & Google 技术面试全记录","url":"/hotlink16/","content":"\n[Google 技术面试全记录](https://mp.weixin.qq.com/s?__biz=MzIyMDkwODczNw==&mid=2247486410&idx=1&sn=bf9f6d79f1f96ff7af91af7972c70982&scene=21#wechat_redirect)\n\n在通过了Google技术面之后，我中途退出了应聘流程。我知道你会怎么想：“你疯了吗？！谁会中途退出Google面试？”\n这篇博文将讨论我在Google面试中的经历，以及通过技术面流程的技巧（适用于任何公司的技术面）。\n\n[关于前端安全的 13 个提示](https://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&mid=2247488632&idx=1&sn=503c5d1ee84919df1cb39b8837c53e85&scene=21#wechat_redirect)\n\n无论你是 React.js、Angular、Vue.js 程序员还是前端页面仔，你的代码都可以成为引诱黑客入侵的大门。\n作为前端开发人员，我们最关心的是性能、SEO 和 UI/UX——安全性却经常被忽略。\n\n[换个角度入门 K8s](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247495778&idx=1&sn=77c2c5662b0a98da9521848297d3f371&scene=21#wechat_redirect)\n\n去年下半年，我做了一次转岗，开始接触到 kubernetes，虽然对 K8s 的认识还非常的不全面，但是非常想分享一下自己的一些收获，希望通过本文能够帮助大家对 K8s 有一个入门的了解。文中有不对的地方，还请各位老司机们帮助指点纠正。\n\n[Vue SSR 即时编译技术](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651236544&idx=2&sn=8c684c77c6d7b8403409128d4b32dc83&scene=21#wechat_redirect)\n\n当我们在服务端渲染 Vue 应用时，无论服务器执行多少次渲染，大部分 VNode 渲染出的字符串是不变的，它们有一些来自于模板的静态 html，另一些则来自模板动态渲染的节点（虽然在客户端动态节点有可能会变化，但是在服务端它们是不变的）。将这两种类型的节点提取出来，仅在服务端渲染真正动态的节点（serverPrefetch 预取数据相关联的节点），可以显著的提升服务端的渲染性能。\n\n[Nginx为什么快到根本停不下来？](https://mp.weixin.qq.com/s?__biz=MzAxMTkwODIyNA==&mid=2247495132&idx=1&sn=c9e6858e2858e4cc9d029325988d7b48&scene=21#wechat_redirect)\n\nNginx 是一个免费的，开源的，高性能的 HTTP 服务器和反向代理，以及 IMAP / POP3 代理服务器。\nNginx 以其高性能，稳定性，丰富的功能，简单的配置和低资源消耗而闻名。本文从底层原理分析 Nginx 为什么这么快！\n\n[从零实现webpack热更新](https://mp.weixin.qq.com/s?__biz=MzI2NTk2NzUxNg==&mid=2247485031&idx=2&sn=0a252248c75edf31cfd0f1ba04c29133&scene=21#wechat_redirect)\n\n本文以剖析webpack-dev-server源码，从零开始实现一个webpack热更新HMR，深入了解webpack-dev-server、webpack-dev-middleware、webpack-hot-middleware的实现机制，彻底搞懂他们的原理，在面试过程中这个知识点能答的非常出彩，在搭建脚手架过程中这块能得心应手。知其然并知其所以然，更上一层楼。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"如何实现一个LRU算法","url":"/lru/","content":"\nLRU算法是指最近最少使用算法。\n\n那么如何实现这种算法呢？我们以数组为例先来分析一下思路：\n\n假设我们有一个数组，我们规定数组越靠前面的元素代表即将淘汰的元素，而数组最后面元素代表最近有使用过的数据。\n\n当我们从缓存中访问一个数据的时候：\n1. 如果该数据存在，则将该数据放到数组最后面，并返回该数据\n2. 如果数据不存在，则返回-1\n\n当我们往缓存中添加一个数据的时候：\n1. 如果该数据存在，则删除对应的元素(其实本意是要将该数据移动到数组最后面，这里直接先删除，后面再添加)\n2. 判断数组长度是否超过限制\n3. 如果超过限制，则删除数组最前面的元素，即下标为0的元素\n4. 将数据添加到数组最后面\n\n**通俗点来说，就是只要这条数据被访问了或者是添加到缓存中，我们都将它放到数组最后面。**\n\n**如果添加时候容量已经满了，就把数组最前面的元素删除。**\n\n根据这种思路，我们就可以实现一个LRU的算法。可以使用链表、数组、Map等等去实现。\n\n这里以一个数组为例：(这种方式其实效率很差，只为了理解思路，根据这个思路，你可以用链表等其他更高效的方式去实现)\n```\nclass LRUCache {\n  constructor(capacity) {\n    this.pool = [];\n    this.capacity = capacity;\n  }\n\n  hasKey(key) {\n    return this.pool.findIndex(item => item.key === key);\n  };\n\n  put(key, value) {\n    // 如果key存在，就删除这个元素，因为后面会直接添加到数组最后面\n    const index = this.hasKey(key);\n    if (index >= 0) {\n      this.pool.splice(index, 1);\n    }\n\n    // 超过容量就把第一个扔掉\n    if (this.pool.length >= this.capacity) {\n      this.pool.shift();\n    }\n    this.pool.push({ key, value });\n  }\n\n  get(key) {\n    // 访问了某个key，就需要把这个key对应的元素放到数组最后面\n    const index = this.hasKey(key);\n    const rtv = this.pool[index];\n    if (index >= 0) {\n      this.pool.splice(index, 1);\n      this.pool.push(rtv);\n      return rtv.value;\n    }\n    return -1;\n  }\n}\n```\n","tags":["算法"]},{"title":"第15期 为新的Facebook.com重建我们的技术栈 & HTTP/3原理与实践","url":"/hotlink15/","content":"\n[HTTP/3原理与实践](https://mp.weixin.qq.com/s?__biz=MzI4NzEyMjUxMA==&mid=2649069145&idx=1&sn=6aab52cf10dbbec2a0d5b4a0385f3780&scene=21#wechat_redirect)\n\n2015 年 HTTP/2 标准发表后，大多数主流浏览器也于当年年底支持该标准。此后，凭借着多路复用、头部压缩、服务器推送等优势，HTTP/2 得到了越来越多开发者的青睐。不知不觉的 HTTP 已经发展到了第三代，鹅厂也紧跟技术潮流，很多项目也在逐渐使用 HTTP/3。本文基于 QQ兴趣部落接入 HTTP/3 的实践，聊一聊 HTTP/3 的原理以及业务接入的方式。\n\n[为新的Facebook.com重建我们的技术栈](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651236491&idx=1&sn=16ce83f02ecb7eefee0b1cb58d971c27&scene=21#wechat_redirect)\n\n当我们考虑如何构建一个新的网络应用—一个为现代浏览器设计的、具有用户对Facebook（我们已知的）所有期望的功能，我们现有的技术栈无法支持我们所需要的类似于桌面应用的感觉和性能。完全重写是非常罕见的，但在这种情况下，由于过去十年来Web技术发生了很多变化，我们知道这是我们实现性能和未来可持续发展目标的唯一途径。今天，我们就分享一下我们在重构Facebook.com时的经验教训，使用React（一种用于构建用户界面的声明式JavaScript库）和Relay（React的GraphQL客户端）来重构Facebook.com。\n\n[HTTP 无状态中的 \"状态\" 到底指的是什么？](https://mp.weixin.qq.com/s?__biz=MjM5MDc4MzgxNA==&mid=2458454562&idx=1&sn=a5fe5f7f2850119d7ddf6f3ba22f20e5&scene=21#wechat_redirect)\n\n最近在好好了解http，发现对介绍http的第一句话【http协议是无状态的，无连接的】就无法理解了：无状态的【状态】到底指的是什么？\n\n[图解 HTTP 缓存](https://mp.weixin.qq.com/s?__biz=MzI0NTE5NzYyMw==&mid=2247484110&idx=1&sn=23cd33596d6f4a6a6b71b852a1b6c2c6&scene=21#wechat_redirect)\n\nHTTP 的缓存机制，可以说这是前端工程师需要掌握的重要知识点之一。本文将针对 HTTP 缓存整体的流程做一个详细的讲解，争取做到大家读完整篇文章后，对缓存有一个整体的了解。\n\n[面试题：说说事件循环机制(满分答案来了)](https://mp.weixin.qq.com/s?__biz=MzI2NTk2NzUxNg==&mid=2247485017&idx=2&sn=817e8b5d78fe8d46a2d8e62bbe870c50&scene=21#wechat_redirect)\n\n1. 先说基本知识点，宏任务、微任务有哪些\n2. 说事件循环机制过程，边说边画图出来\n3. 说async/await执行顺序注意，可以把 chrome 的优化，做法其实是违反了规范的，V8 团队的PR这些自信点说出来，显得4. 你很好学，理解得很详细，很透彻。\n5. 把node的事件循环也说一下，重复1、2、3点，node中的第3点要说的是node11前后的事件循环变动点。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"函数式组件与类组件有何不同？","url":"/react-fc-and-class-component-different/","content":"\n转载自：https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/\n\n#### 与React类组件相比，React函数式组件究竟有何不同？\n\n在过去一段时间里，典型的回答是类组件提供了更多的特性（比如state）。当有了[Hooks](https://reactjs.org/docs/hooks-intro.html)后，答案就不再是这样了。\n\n或许你曾听过它们中的某一个在性能上的表现优于另一个。那是哪一个？很多此类的判断标准都存在这样那样的[缺陷（flawed）](https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f?source=your_stories_page---------------------------)，所以我会谨慎看待从它们中[得出的结论](https://github.com/ryardley/hooks-perf-issues/pull/2)。性能主要取决于代码的作用，而不是选择函数式还是类组件。在我们的观察中，尽管优化策略各有略微[不同](https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render)，但性能差异可以忽略不计。\n\n在任何一种情况下，除非你有其他原因并且不介意成为早期使用者，否则我们[不推荐](https://reactjs.org/docs/hooks-faq.html#should-i-use-hooks-classes-or-a-mix-of-both)重构你现有的组件。Hooks还很年轻（如同2014年的React），并且有些“最佳实践”还没有找到它们的切入方式。\n\n那么现在是个什么情况？React的函数式组件和类组件之间是否有任何根本上的区别？当然有 —— 在心智模型上。在这篇文章中，我将阐述它们之间的最大区别。 自2015年我们推出函数式组件以来，它一直存在，但是经常被忽略：\n\n> 函数式组件捕获了渲染所用的值。（Function components capture the rendered values.）\n\n让我们来看看这意味着什么。\n\n> 注意：这篇文章不是对函数式组件或者类组件的价值判断。我只是在阐述在React中这两种编程模型之间的区别。关于更广泛地采用函数式组件的问题，请查看Hooks FAQ。\n\n思考这个组件:\n\n```\nfunction ProfilePage(props) {\n  const showMessage = () => {\n    alert('Followed ' + props.user);\n  };\n\n  const handleClick = () => {\n    setTimeout(showMessage, 3000);\n  };\n\n  return (\n    <button onClick={handleClick}>Follow</button>\n  );\n}\n```\n\n它渲染了一个利用`setTimeout`来模拟网络请求，然后显示一个确认警告的按钮。例如，如果`props.user`是`Dan`，它会在三秒后显示`Followed Dan`。非常简单。\n\n> 请注意，在上面的示例中我是否用了箭头函数或者函数声明并不重要。function handleClick()也将完全以同样方式有效。\n\n如果是类组件我们怎么写？一个简单的重构可能就象这样：\n```\nclass ProfilePage extends React.Component {\n  showMessage = () => {\n    alert('Followed ' + this.props.user);\n  };\n\n  handleClick = () => {\n    setTimeout(this.showMessage, 3000);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>Follow</button>;\n  }\n}\n```\n\n通常我们认为，这两个代码片段是等效的。人们经常在这两种模式中自由的重构代码，但是很少注意到它们的含义:\n![wtf](https://overreacted.io/1d3c7a341ee3fcadc79df00e7d872e4b/wtf.gif)\n\n然而，这两个代码片段还是有略微的不同。 仔细的看看它们。现在看出他们的不同了吗？就我个人而言，我花了好一会儿才看明白这一点。\n\n接下来的文章是“剧透”，如果你想自己搞明白，你可以查看这个[live demo](https://codesandbox.io/s/pjqnl16lm7)。 本文的生育部分解释了这里面的差异以及阐述了为什么这很重要。\n\n在我们继续之前，我想强调一点，我所描述的差异与 React Hooks 完全无关。上面的例子中甚至没有使用 Hooks！\n\n它全部是关于 React 中函数式组件与类组件的区别的。如果你打算在你的 React 应用中更频繁地使用函数式组件，你可能需要理解它。\n\n我们将通过 React 应用程序中的一个常见错误来说明其中的不同。\n\n---\n\n打开这个 [sandbox](https://codesandbox.io/s/pjqnl16lm7) 例子， 你将看到一个当前账号选择框以及两个上面 ProfilePage 的实现 —— 每个都渲染了一个 Follow 按钮。\n\n尝试按照以下顺序来分别使用这两个按钮：\n\n1. 点击 其中某一个 Follow 按钮。\n2. 在3秒内 切换 选中的账号。\n3. 查看 弹出的文本。\n\n你将看到一个奇特的区别:\n\n* 当使用 函数式组件 实现的 ProfilePage, 当前账号是 Dan 时点击 Follow 按钮，然后立马切换当前账号到 Sophie，弹出的文本将依旧是 'Followed Dan'。\n* 当使用 类组件 实现的 ProfilePage, 弹出的文本将是 'Followed Sophie'：\n\n![bug git](https://overreacted.io/386a449110202d5140d67336a0ade5a0/bug.gif)\n\n在这个例子中，第一个行为是正确的。如果我关注一个人，然后导航到了另一个人的账号，我的组件不应该混淆我关注了谁。 在这里，类组件的实现很明显是错误的。\n\n(非常推荐你 关注 Sophie。)\n\n---\n\n所以为什么我们的例子中类组件会有这样的表现？\n\n让我们来仔细看看我们类组件中的 showMessage 方法：\n```\nclass ProfilePage extends React.Component {\n  showMessage = () => {\n    alert('Followed ' + this.props.user);\n  };\n```\n\n这个类方法从 this.props.user 中读取数据。在 React 中 Props 是不可变(immutable)的，所以他们永远不会改变。然而，this是，而且永远是，可变(mutable)的。\n\n事实上，这就是类组件 this 存在的意义。React本身会随着时间的推移而改变，以便你可以在渲染方法以及生命周期方法中得到最新的实例。\n\n所以如果在请求已经发出的情况下我们的组件进行了重新渲染，this.props将会改变。showMessage方法从一个“过于新”的props中得到了user。\n\n这暴露了一个关于用户界面性质的一个有趣观察。如果我们说UI在概念上是当前应用状态的一个函数，那么事件处理程序则是渲染结果的一部分 —— 就像视觉输出一样。我们的事件处理程序“属于”一个拥有特定 props 和 state 的特定渲染。\n\n然而，调用一个回调函数读取 this.props 的 timeout 会打断这种关联。我们的 showMessage 回调并没有与任何一个特定的渲染“绑定”在一起，所以它“失去”了正确的 props。从 this 中读取数据的这种行为，切断了这种联系。\n\n让我们假设函数式组件不存在。我们将如何解决这个问题？\n\n我们想要以某种方式“修复”拥有正确 props 的渲染与读取这些 props 的showMessage回调之间的联系。在某个地方props被弄丢了。\n\n一种方法是在调用事件之前读取this.props，然后将他们显式地传递到timeout回调函数中去：\n```\nclass ProfilePage extends React.Component {\n  showMessage = (user) => {\n    alert('Followed ' + user);\n  };\n\n  handleClick = () => {\n    const {user} = this.props;\n    setTimeout(() => this.showMessage(user), 3000);\n  };\n\n  render() {\n    return <button onClick={this.handleClick}>Follow</button>;\n  }\n}\n```\n\n这种方法 会起作用。然而，这种方法使得代码明显变得更加冗长，并且随着时间推移容易出错。如果我们需要的不止是一个props怎么办？如果我们还需要访问state怎么办？如果 showMessage 调用了另一个方法，然后那个方法中读取了 this.props.something 或者 this.state.something，我们又将遇到同样的问题。然后我们不得不将this.props和this.state以函数参数的形式在被showMessage调用的每个方法中一路传递下去。\n\n这样的做法破坏了类提供的工程学。同时这也很难让人去记住传递的变量或者强制执行，这也是为什么人们总是在解决bugs。\n\n同样的，在handleClick中内联地写alert代码也无法解决问题。我们希望以允许将其拆分为多个方法的方式来构造组织代码，但同时也能读取与某次组件调用形成的渲染结果对应的props和state。这个问题并不是React所独有的 —— 你可以在任何一个将数据放入类似 this 这样的可变对象中的UI库中重现它。\n\n或许，我们可以在构造函数中绑定方法？\n```\nclass ProfilePage extends React.Component {\n  constructor(props) {\n    super(props);\n    this.showMessage = this.showMessage.bind(this);\n    this.handleClick = this.handleClick.bind(this);\n  }\n\n  showMessage() {\n    alert('Followed ' + this.props.user);\n  }\n\n  handleClick() {\n    setTimeout(this.showMessage, 3000);\n  }\n\n  render() {\n    return <button onClick={this.handleClick}>Follow</button>;\n  }\n}\n```\n\n不，这没有解决任何问题。记住，我们面对的问题是我们从this.props中读取数据太迟了——读取时已经不是我们所需要使用的上下文了！然而，如果我们能利用JavaScript闭包的话问题将迎刃而解。\n\n通常来说我们会避免使用闭包，因为它会让我们难以想象一个可能会随着时间推移而变化的变量。但是在React中，props和state是不可变得！（或者说，在我们的强烈推荐中是不可变得。）这就消除了闭包的一个主要缺陷。\n\n这就意味着如果你在一次特定的渲染中捕获那一次渲染所用的props或者state，你会发现他们总是会保持一致，就如同你的预期那样：\n```\nclass ProfilePage extends React.Component {\n  render() {\n    // Capture the props!\n    const props = this.props;\n\n    // Note: we are *inside render*.\n    // These aren't class methods.\n    const showMessage = () => {\n      alert('Followed ' + props.user);\n    };\n\n    const handleClick = () => {\n      setTimeout(showMessage, 3000);\n    };\n\n    return <button onClick={handleClick}>Follow</button>;\n  }\n}\n```\n\n你在渲染的时候就已经“捕获”了props：\n\n![pokemon](https://overreacted.io/fa483dd5699aac1350c57591770a49be/pokemon.gif)\n\n这样，在它内部的任何代码（包括showMessage）都保证可以得到这一次特定渲染所使用的props。React再也不会“动我们的奶酪”。\n\n然后我们可以在里面添加任意多的辅助函数，它们都会使用被捕获的props和state。闭包万岁！\n\n上面的例子是正确的，但是看起来很奇怪。如果你在render方法中定义各种函数，而不是使用class的方法，那么使用类的意义在哪里？\n\n事实上，我们可以通过删除类的“包裹”来简化代码：\n```\nfunction ProfilePage(props) {\n  const showMessage = () => {\n    alert('Followed ' + props.user);\n  };\n\n  const handleClick = () => {\n    setTimeout(showMessage, 3000);\n  };\n\n  return (\n    <button onClick={handleClick}>Follow</button>\n  );\n}\n```\n\n就像上面这样，props仍旧被捕获了 —— React将它们作为参数传递。不同于this，props对象本身永远不会被React改变。\n\n如果你在函数定义中解构props，那将更加明显：\n```\nfunction ProfilePage({ user }) {\n  const showMessage = () => {\n    alert('Followed ' + user);\n  };\n\n  const handleClick = () => {\n    setTimeout(showMessage, 3000);\n  };\n\n  return (\n    <button onClick={handleClick}>Follow</button>\n  );\n}\n```\n\n当父组件使用不同的props来渲染ProfilePage时，React会再次调用ProfilePage函数。但是我们点击的事件处理函数，“属于”具有自己的user值的上一次渲染，并且showMessage回调函数也能读取到这个值。它们都保持完好无损。\n\n这就是为什么，在上面那个demo的函数式版本中，点击关注Sophie的账号，然后改变选择为Sunil仍旧会弹出'Followed Sophie'：\n![fix](https://overreacted.io/84396c4b3982827bead96912a947904e/fix.gif)\n\n这个行为展现是正确的 (同时你也可能会想要 [关注Sunil](https://mobile.twitter.com/threepointone)!)\n\n现在我们明白了React中函数式组件和类组件之间的巨大差别：\n\n**函数式组件捕获了渲染所使用的值。**\n\n使用Hooks，同样的原则也适用于state。 看这个例子：\n```\nfunction MessageThread() {\n  const [message, setMessage] = useState('');\n\n  const showMessage = () => {\n    alert('You said: ' + message);\n  };\n\n  const handleSendClick = () => {\n    setTimeout(showMessage, 3000);\n  };\n\n  const handleMessageChange = (e) => {\n    setMessage(e.target.value);\n  };\n\n  return (\n    <>\n      <input value={message} onChange={handleMessageChange} />\n      <button onClick={handleSendClick}>Send</button>\n    </>\n  );\n}\n```\n\n（这是[演示demo](https://codesandbox.io/s/93m5mz9w24)。）\n\n尽管这不是一个非常好的消息应用的UI，但它说明了同样的观点：如果我发送一条特定的消息，组件不应该对实际发送的是哪条消息感到困惑。这个函数组件的message变量捕获了“属于”返回了被浏览器调用的单击处理函数的那一次渲染。所以当我点击“发送”时message被设置为那一刻在input中输入的内容。\n\n因此我们知道，在默认情况下React中的函数会捕获props和state。但是如果我们想要读取并不属于这一次特定渲染的，最新的props和state呢？如果我们想要“[从未来读取他们](https://dev.to/scastiel/react-hooks-get-the-current-state-back-to-the-future-3op2)”呢？\n\n在类中，你通过读取this.props或者this.state来实现，因为this本身时可变的。React改变了它。在函数式组件中，你也可以拥有一个在所有的组件渲染帧中共享的可变变量。它被成为“ref”：\n```\nfunction MyComponent() {\n  const ref = useRef(null);\n  // You can read or write `ref.current`.\n  // ...\n}\n```\n\n但是，你必须自己管理它。\n\n一个ref与一个实例字段扮演同样的角色。这是进入可变的命令式的世界的后门。你可能熟悉’DOM refs’，但是ref在概念上更为广泛通用。它只是一个你可以放东西进去的盒子。\n\n甚至在视觉上，this.something就像是something.current的一个镜像。他们代表了同样的概念。\n\n默认情况下，React不会在函数式组件中为最新的props和state创造refs。在很多情况下，你并不需要它们，并且分配它们将是一种浪费。但是，如果你愿意，你可以这样手动地来追踪这些值：\n```\nfunction MessageThread() {\n  const [message, setMessage] = useState('');\n  const latestMessage = useRef('');\n\n  const showMessage = () => {\n    alert('You said: ' + latestMessage.current);\n  };\n\n  const handleSendClick = () => {\n    setTimeout(showMessage, 3000);\n  };\n\n  const handleMessageChange = (e) => {\n    setMessage(e.target.value);\n    latestMessage.current = e.target.value;\n  };\n```\n\n如果我们在showMessage中读取message，我们将得到在我们按下发送按钮那一刻的信息。但是当我们读取latestMessage.current，我们将得到最新的值 —— 即使我们在按下发送按钮后继续输入。\n\n你可以自行查看这 俩demo来比较它们之间的不同。ref是一种“选择退出”渲染一致性的方法，在某些情况下会十分方便。\n\n通常情况下，你应该避免在渲染期间读取或者设置refs，因为它们是可变得。我们希望保持渲染的可预测性。然而，如果我们想要特定props或者state的最新值，那么手动更新ref会有些烦人。我们可以通过使用一个effect来自动化实现它：\n```\nfunction MessageThread() {\n  const [message, setMessage] = useState('');\n\n  // 保持追踪最新的值。\n  const latestMessage = useRef('');\n  useEffect(() => {\n    latestMessage.current = message;\n  });\n\n  const showMessage = () => {\n    alert('You said: ' + latestMessage.current);\n  };\n```\n\n(这是[demo](https://codesandbox.io/s/yqmnz7xy8x)。)\n\n我们在一个effect内部执行赋值操作以便让ref的值只会在DOM被更新后才会改变。这确保了我们的变量突变不会破坏依赖于可中断渲染的时间切片和 Suspense等特性。\n\n通常来说使用这样的ref并不是非常地必要。捕获props和state通常是更好的默认值。然而，在处理类似于intervals和订阅这样的命令式API时，ref会十分便利。记住，你可以像这样跟踪任何值 —— 一个prop，一个state变量，整个props对象，或者甚至一个函数。\n\n这种模式对于优化来说也很方便 —— 例如当useCallback本身经常改变时。然而，使用一个reducer通常是一个更好的解决方式。（未来博客文章的主题！）\n\n在这篇文章中，我们已经看过了类组件中常见的破碎模式，以及闭包如何帮助我们修复它。然而，你可能注意到，当你尝试通过指定一个依赖数组来优化Hooks时，你可能会遇到带有过时闭包的问题。这是否意味着闭包是一个问题？我不这么认为。\n\n正如我们上面看到的，闭包实际上帮我们解决了很难注意到的细微问题。同样，它们也使得在并发模式下能更轻松地编写能够正确运行的代码。这是可行的，因为组件内部的逻辑在渲染它时捕获并包含了正确的props和state。\n\n目前为止我看到的所有情况中，所谓的“陈旧的闭包”问题的出现多是由于错误的假设了“函数不会改变”或者“props永远是一样的”。事实并非如此，而我希望这篇文章有助于澄清这一点。\n\n函数捕获了他们的props和state —— 因此它们的标识也同样重要。这不是一个bug，而是一个函数式组件的特性。例如，对于useEffect或者useCallback来说，函数不应该被排除在“依赖数组”之外。（正确的解决方案通常是使用上面说过的useReducer或者useRef —— 我们将很快会在文档中说明如何在它们两者中进行选择。）\n\n当我们用函数来编写大部分的React代码时，我们需要调整关于优化代码和什么变量会随着时间改变的认知与直觉。\n\n正如Fredrik所说：\n\n**到目前为止，我发现的有关于hooks的最好的心里规则是“写代码时要认为任何值都可以随时更改”。**\n\n函数也不例外。这需要一段时间才能成为React学习资料中的常识。它需要一些从类的思维方式中进行一些调整。但我希望这篇文章能够帮助你以新的眼光来看待它。\n\nReact函数总是捕获他们的值 —— 现在我们也知道这是为什么了。\n\n![pikachu](https://overreacted.io/fc3bddf6d4ca14bc77917ac0cfad3608/pikachu.gif)\n\n它们是完全不同的宝可梦哦。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["转载","React"]},{"title":"如何实现一个优雅的jsBridge","url":"/jsbridge/","content":"\n### 什么是jsbridge\njsbridge是客户端和H5沟通的桥梁，通过它，我们可以获取部分原生能力，同时客户端也可以使用我们提供的一些方法。实现双向通信。\n\n### jsbridge原理\n客户端可以通过webview里面注入一些javascript的上下文，可以理解为在window对象上挂载了一些方法，然后H5通过特定的对象可以获取到这个方法，反过来也是一样，js挂载了一些方法到window对象上，客户端也就可以调用js的某些方法。\n\n### 具体实现\n\n#### 方案一：注入API\n\n##### IOS UIWebView\n\n```\nJSContext *context = [uiWebView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"];\n\ncontext[@\"postBridgeMessage\"] = ^(NSArray<NSArray *> *calls) {\n    // Native 逻辑\n};\n```\n\nH5使用`window.postBridgeMessage(message)`调用\n\n##### IOS WKWebView\n```\n@interface WKWebVIewVC ()<WKScriptMessageHandler>\n\n@implementation WKWebVIewVC\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];\n    configuration.userContentController = [[WKUserContentController alloc] init];\n    WKUserContentController *userCC = configuration.userContentController;\n    // 注入对象，前端调用其方法时，Native 可以捕获到\n    [userCC addScriptMessageHandler:self name:@\"nativeBridge\"];\n\n    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];\n\n    // TODO 显示 WebView\n}\n\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {\n    if ([message.name isEqualToString:@\"nativeBridge\"]) {\n        NSLog(@\"前端传递的数据 %@: \",message.body);\n        // Native 逻辑\n    }\n}\n```\n\nH5使用`window.webkit.messageHandlers.nativeBridge.postMessage(message)`方式调用。\n\n来看一下H5端具体实现\n\n假设我们需要一个`getUserInfo`方法，用于H5获取当前APP登录用户的信息。\n\n那么我们js可以这样：\n\n```\nimport registerCallback from '../registerCallback';\n\nexport default function getUserInfo() {\n  return new Promise((resolve, reject) => {\n    try {\n      window.webkit.messageHandlers.getUserInfo.postMessage({\n        callback: registerCallback(resolve),\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n```\n\n我们定义一个`getUserInfo`方法，这个方法会去调用`window.webkit.messageHandlers.getUserInfo.postMessage`方法，这是客户端写入的方法，然后传入一个callback方法。客户端会通过callback方法把我们需要的信息返回给我们。\n\n我们可以再看下`registerCallback`这个方法是什么：\n```\nwindow.knCallbacks = {};\n\nfunction makeRandomId(func) {\n  return `${func.name || 'anonymous'}_${Date.now()}`;\n}\n\nexport default function registerCallback(callback, keepAlive) {\n  if (!callback) {\n    return null;\n  }\n\n  const callbackId = makeRandomId(callback);\n  window.knCallbacks[callbackId] = (data) => {\n    let result;\n    if (typeof data === 'object') {\n      result = data;\n    } else if (typeof data === 'string') {\n      try {\n        result = JSON.parse(data);\n      } catch (e) {\n        result = data;\n      }\n    }\n    callback(result);\n    if (!keepAlive) {\n      delete window.knCallbacks[callbackId];\n    }\n  };\n\n  return `knCallbacks.${callbackId}`;\n}\n```\n\n在这个方法里面，我们会为promise的resolve方法生成一个随机函数名，避免出现window可能会有同名函数导致将其覆盖的问题。\n然后我们根据生成的函数名重写一个函数，将这个函数最后返回给外部的callback，传递给了客户端。\n这里的data就是客户端调用callback传递过来的数据。\n我们在这里对数据做一些处理，然后给到callback，也就是promise的resolve。\n\n##### Android\n\n客户端实现：\n```\npublicclassJavaScriptInterfaceDemoActivityextendsActivity{\n  private WebView Wv;\n\n  @Override\n  publicvoidonCreate(Bundle savedInstanceState){\n    super.onCreate(savedInstanceState);\n    Wv = (WebView)findViewById(R.id.webView);\n    final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);\n    Wv.getSettings().setJavaScriptEnabled(true);\n    Wv.addJavascriptInterface(myJavaScriptInterface, \"knJSBridge\");\n    // TODO 显示 WebView\n  }\n\n  publicclassJavaScriptInterface{\n    Context mContext;\n    JavaScriptInterface(Context c) {\n        mContext = c;\n    }\n    publicvoidpostMessage(String webMessage){\n        // Native 逻辑\n    }\n  }\n}\n```\n\nH5实现\n```\nimport registerCallback from '../registerCallback';\n\nexport default function getUserInfo() {\n  return new Promise((resolve, reject) => {\n    try {\n      window.knJSBridge.getUserInfo(JSON.stringify({\n        callback: registerCallback(resolve),\n      }));\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n```\n\n这里我们其实可以看到，knJSBridge其实是我们和客户端约定的一个字段。然后我们通过`window.knJSBridge`就可以调用客户端的方法了。\nregisterCallback和IOS的是一样的。\n\n根据上面我们H5这里最后可以实现这样一个结构的jsbridge\n\n```\njsbridge\n  - index.js\n  - ios/\n    - index.js\n    - getUserInfo.js\n  - android/\n    - index.js\n    - getUserInfo.js\n```\n\n```\n// jsbridge/index.js\nimport iosBridge from './iOs';\nimport androidBridge from './android';\n\nexport default class Bridge {\n  constructor() {\n    super();\n    if (isAndroid) {\n      this.jsbridge = androidBridge;\n    } else {\n      this.jsbridge = iosBridge;\n    }\n  }\n  getUserInfo = (...args) => this.jsbridge.getUserInfo(...args);\n}\n\n// ios/index.js\nimport getUserInfo from './getUserInfo';\n\nexport {\n  getUserInfo\n}\n\n// ios/getUserInfo.js\nimport registerCallback from '../registerCallback';\n\nexport default function getUserInfo() {\n  return new Promise((resolve, reject) => {\n    try {\n      window.webkit.messageHandlers.getUserInfo.postMessage({\n        callback: registerCallback(resolve),\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n// android/index.js\nimport getUserInfo from './getUserInfo';\n\nexport {\n  getUserInfo\n}\n\n// android/getUserInfo.js\nimport registerCallback from '../registerCallback';\n\nexport default function getUserInfo() {\n  return new Promise((resolve, reject) => {\n    try {\n      window.webkit.messageHandlers.getUserInfo.postMessage({\n        callback: registerCallback(resolve),\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n```\n\n#### 方案二：url拦截\n这种方案就是H5构造一个iframe，通过给iframe设置src发起请求，然后客户端拦截请求实现。\n\n一般会将url设为一个特殊的字符串，比如`https://__bridge__`这个样子，然后后面跟上我们需要传递的数据，包括一个callback函数名，客户拦截这种请求，然后通过callback将数据传递回来。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["JavaScript"]},{"title":"第13期 腾讯IMWEB团队《未来可期的TypeScript》& 拼多多和酷家乐面试总结(已拿offer)","url":"/hotlink13/","content":"\n[腾讯IMWEB团队《未来可期的TypeScript》](https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&mid=2247485046&idx=1&sn=1046b23d254bcdba9803e6c76b83ffe8&scene=21#wechat_redirect)\n\n文章讲述了自己从一名 TypeScript 抵制者转变为支持者的心路历程，以及 TypeScript 在在线教育团队中的实践经验，并对团队新项目是否该引入 TypeScript、如何快速搭建、以及现有项目如何向 TypeScript 迁移提供策略性建议与方案。\n\n[微前端在小米 CRM 系统的实践](https://mp.weixin.qq.com/s?__biz=MzU3MDAyNDgwNA==&mid=2247485705&idx=1&sn=72485cc83eb607ffeab3b2eb22b49805&scene=21#wechat_redirect)\n\n大型组织的组织结构、软件架构在不断地发生变化。移动优先（Mobile First）、App中台（One App）、中台战略等，各种口号在不断的提出、修改和演进。同时，业务也在不断地发展，导致应用不断膨胀，进一步映射到软件架构上。\n\n[前端性能优化之谈谈常见的性能指标及上报策略](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650591715&idx=1&sn=aa8e6d5ed7bba8f4c3af67b889b54a91&scene=21#wechat_redirect)\n\n性能优化是所有前端人的追求，在这条路上，方法多种多样。这篇文章，说一下可以怎样定义性能指标及上报。\n\n[拼多多和酷家乐面试总结(已拿offer)](https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485303&idx=1&sn=c003da72428fcd020af03ea37a586490&scene=21#wechat_redirect)\n\n我目前面了五家公司：滴滴、蚂蚁、拼多多、酷家乐、字节跳动，拼多多和酷家乐基本已拿到 offer，蚂蚁二面完了，滴滴和字节即将三面，我先把我已经面过的面经先总结出来，其他的不管过没过，这周内我都会总结出来，希望能给到正在找工作同学的帮助。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"第12期 前端越管越宽，腾讯Now直播如何把监控体系做到极致 & 用Jest来给React完成一次妙不可言的~单元测试","url":"/hotlink12/","content":"\n[前端越管越宽，腾讯Now直播如何把监控体系做到极致？](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247494394&idx=1&sn=94c15aaffb191dfa1f96f6ec00dfb88a&scene=21#wechat_redirect)\n\n在 GMTC 全球大前端技术大会（深圳站）2019 上，腾讯高级 Web 前端工程师何方舟以产品遇到的实际问题挑战为背景，详细讲解了实现大前端监控的一些解决方案。本文即根据何方舟的演讲整理而成。以下为正文。\n\n[通俗易懂的红黑树图解(下)](https://mp.weixin.qq.com/s?__biz=MzI0NTE5NzYyMw==&mid=2247484070&idx=1&sn=0e838c5acb07aabefcaee87cb2aabe09&scene=21#wechat_redirect)\n\n回顾一下 通俗易懂的红黑树图解(上)，上篇首先介绍了二叉树的定义以及二叉树的查找，然后介绍了红黑树的五点性质以及红黑树的变色、左旋以及右旋等操作，最后结合变色、左旋及右旋详细讲解了插入节点的五种场景。而本篇通俗易懂的红黑树图解(下)是在上篇的基础上讲解红黑树最后一种操作-删除节点，删除节点相对插入节点会复杂一点，但通过分类归纳出不同的场景，能更容易理解和记忆。\n\n[用Jest来给React完成一次妙不可言的~单元测试](https://mp.weixin.qq.com/s?__biz=MzIwNTc4OTU2NA==&mid=2247484818&idx=1&sn=dc2f5c2c8df7672387f81fa95b1575ef&scene=21#wechat_redirect)\n\n在2020的今天，构建一个 web 应用对于我们来说，并非什么难事。因为有很多足够多优秀的的前端框架（比如 React，Vue 和 Angular）；以及一些易用且强大的UI库（比如 Ant Design）为我们保驾护航，极大地缩短了应用构建的周期。\n\n[简单几步让你的 JS 写得更漂亮](https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247485519&idx=1&sn=d261a4ebd2cbfcc092bb30d54af833e8&scene=21#wechat_redirect)\n\n网上有不少关于 JS 编写优化建议，这里我根据自己的经验提出一些比较有用的意见。\n\n[为什么你的网页需要 CSP?](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826826&idx=2&sn=bc707e702f63c6a7ec79ada43f9308a2&scene=21#wechat_redirect)\n\n内容安全策略（CSP）是一个 HTTP Header，CSP 通过告诉浏览器一系列规则，严格规定页面中哪些资源允许有哪些来源， 不在指定范围内的统统拒绝。\n使用它是防止跨站点脚本（XSS）漏洞的最佳方法。由于难以使用 CSP 对现有网站进行改造（可通过渐进式的方法），因此 CSP 对于所有新网站都是强制性的，强烈建议对所有现有高风险站点进行 CSP 策略配置。\n\n[从URL输入到页面展现到底发生什么？](http://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247483803&idx=1&sn=460597ae3bd3ec10ad3426b7db605074&chksm=c066800df711091b2b6e005a922fff4a6a8e4b7930928a1c60fc0ac657c3ea5061cf1b51563d&scene=21#wechat_redirect)\n\n打开浏览器从输入网址到网页呈现在大家面前，背后到底发生了什么？经历怎么样的一个过程？先给大家来张总体流程图，具体步骤请看下文分解！\n\n[高级前端必知必会：用Koa2 + MySQL搭建全栈项目](https://mp.weixin.qq.com/s?__biz=MzIwNTc4OTU2NA==&mid=2247484831&idx=1&sn=0059ba356ff36111cf7cc254acc7661f&scene=21#wechat_redirect)\n\n作为一名前端开发工程师，我们平常和后端接触最多的就是接口的对接。那么后端同事是怎么写一个接口来给到我们前端的同学去获取数据库数据并做一些花里胡哨的功能呢？今天我们就用Koa2 & mySql来搭建一个后端服务器，实现自己写api的中国梦！\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"如何迈向TypeScript - 工程配置篇","url":"/how-go-to-ts/","content":"\n> 本文主要介绍如何将你现有的项目平滑的迁移至TypeScript。\n\n我们这里以React + Webpack + Babel项目为例。其他类似的项目其实也都大同小异，可以参考进行配置。\n\n### 第一步：支持编译.ts, .tsx文件\n\n首先我们安装相关npm包：\n`npm i typescript @types/react @types/react-dom -D`\n\n然后使用`tsc --init`命令生成`tsconfig.json`文件。\n\n我们将`tsconfig.json`里面的:\n```\n{\n  \"jsx\": \"react\", // 改为react\n  \"noEmit\": true,\n}\n```\n\n接下来我们再安装`npm i @babel/preset-typescript -D`\n\n然后修改`babel`配置文件，增加这个preset:\n```\n{\n  \"presets\": [\n    \"@babel/preset-typescript\"\n  ],\n}\n```\n\n同时我们还需要调整一下`webpack.config.js`文件：\n```\n{\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx']  // 增加.ts, .tsx\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(jsx|tsx)?$/, // 支持ts, tsx\n        use: ['babel-loader'],\n      }\n    ]\n  }\n}\n```\n\n到这一步，我们已经可以将.ts, .tsx文件转换为.js, .jsx文件了，但是是没有ts校验的。\n\n### 第二步：增加类型校验\n\n我们需要通过`tsc`进行校验\n\n在`package.json`里面我们增加一个校验脚本：\n```\n{\n  \"scripts\": {\n    \"ts-check\": \"tsc --watch\"\n  }\n}\n```\n\n这样，执行`npm run ts-check`的时候，就可以对.ts, .tsx类型文件进行校验了。\n\n这个时候，即使ts-check有报错，也不会影响项目本身的构建。\n\n这样，你就可以实现项目中新增内容的ts校验了。\n\n\n如果你想更进一步，把原有的代码也改造成ts，需要怎么做呢，很简单，将.js, .jsx的文件改成.ts, .tsx类型即可。\n然后根据ts的报错去修改的代码。\n\n### 第三步：全面改造\n\n我们可以将所有.js, .jsx文件都改成.ts, .tsx后缀，但是对于一个大的项目来说，可能会产生大量的报错，需要花费很大精力去修改，建议是按模块来分步骤改造。\n\n如果你想批量处理.js, .jsx文件，这里可以使用`shelljs`批量修改文件后缀名\n\n首先我们安装相关npm包：\n```\nnpm i shelljs @types/shelljs ts-node -D\n```\n\n然后新建一个renameJS.ts文件\n\n```\n// renameJS.ts\nimport * as shelljs from 'shelljs'\nshelljs.find('src')\n.filter(file => file.match(/\\.jsx?$/))\n.forEach(file => {\n  const newName = file.replace(/.j(sx?$)/, '.t$1')\n  shelljs.mv(file, newname);\n})\n\n// package.json 增加script\n{\n  \"rename-js\": \"ts-node renameJS.ts\",\n}\n\n// 最后执行npm run rename-js即可\n```\n","tags":["typescript"]},{"title":"第11期 小白必看，JSBridge 初探 & 通俗易懂的红黑树图解(上) & WebGL工作流程解读，一个三角形的诞生","url":"/hotlink11/","content":"\n[小白必看，JSBridge 初探](https://mp.weixin.qq.com/s?__biz=MzI0NTE5NzYyMw==&mid=2247484005&idx=1&sn=43b97435aa13b4427c82bf87a9165c05&scene=21#wechat_redirect)\n\n近些年，移动端普及化越来越高，开发过程中选用 Native 还是 H5 一直是热门话题。Native 和 H5 都有着各自的优缺点，为了满足业务的需要，公司实际项目的开发过程中往往会融合两者进行 Hybrid 开发。Native 和 H5 分处两地，看起来无法联系，那么如何才能让双方协同实现功能呢？\n\n[通俗易懂的红黑树图解(上)](https://mp.weixin.qq.com/s?__biz=MzI0NTE5NzYyMw==&mid=2247483899&idx=1&sn=fb11e2854e11c04763a8e26a9f53d241&scene=21#wechat_redirect)\n\n红黑树本质上是一颗二叉查找树，它是在二叉查找树的基础上给节点增加红黑颜色属性以及五条约束的性质。所以学习红黑树之前，需要先了解一下二叉查找树的知识；红黑树与二叉查找树的查找操作是一模一样的，所以掌握了二叉查找树之后，学习红黑树就只剩下增加及删除节点了（注意：红黑树没有更新节点操作）。\n\n[webpack-dev-middleware 源码解读](https://mp.weixin.qq.com/s?__biz=MzI0NTE5NzYyMw==&mid=2247484052&idx=1&sn=93842fa46cfe1b0cc86f554caff06d0b&scene=21#wechat_redirect)\n\nWebpack 的使用目前已经是前端开发工程师必备技能之一。若是想在本地环境启动一个开发服务，大家只需在 Webpack 的配置中，增加 devServer(https://www.webpackjs.com/configuration/dev-server/) 的配置来启动。devServer 配置的本质是 webpack-dev-server 这个包提供的功能，而 webpack-dev-middleware 则是这个包的底层依赖。\n\n[五分钟看懂 Nginx 负载均衡](https://mp.weixin.qq.com/s?__biz=MzI0NTE5NzYyMw==&mid=2247484065&idx=1&sn=bdcd7acb8d3ff150764e5106bc795df2&scene=21#wechat_redirect)\n\n对于电商平台而言，随着业务的不断发展壮大，网站访问量和数据量也随之急剧增长，该情况的产生给服务器带来了一定的负担。从用户体验层面而言，由于服务器端数据处理带来的时延，往往导致页面的响应速度过慢、操作流畅性受阻等问题。这在某种程度上甚至会潜在影响平台的成交量。提供高效率，高质量的服务成为亟待解决的问题。负载均衡策略的出现和发展成为缓解上述问题的有效途径。本文将带你了解基于 Nginx 实现的负载均衡。\n\n[一篇搞定移动端适配](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650591397&idx=1&sn=118faca487e657e8c946a69fe1decc47&scene=21#wechat_redirect)\n\n手机市场日渐丰富的同时，给我们前端开发人员带来的 “网页内容自适应屏幕尺寸进行显示的问题” 也日渐凸显出来，接下来我们就要细说移动端适配的前世今生及方案。\n\n[WebGL工作流程解读，一个三角形的诞生](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650591583&idx=1&sn=2b8e38bf31fbdbc3956e170d56676b80&scene=21#wechat_redirect)\n\n本文会把WebGL工作的具体流程梳理一遍，WebGL到底是如何渲染出一个三角形的。我们常说把大象装进冰箱需要三步，那么写一个WebGL程序应该也只需要三步：1、把数据放入缓冲区，2、把缓冲区的数据给着色器，3、着色器把数据给GPU。\n\n[当浏览器全面禁用三方 Cookie](https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247485264&idx=2&sn=6e6d0911649f3e24141be25fca19cb2b&scene=21#wechat_redirect)\n\n苹果公司前不久对 Safari 浏览器进行一次重大更新，这次更新完全禁用了第三方  Cookie，这意味着，默认情况下，各大广告商或网站将无法对你的个人隐私进行追踪。而微软和 Mozilla 等也纷纷采取了措施禁用第三方 Cookie，但是由于这些浏览器市场份额较小，并没有给市场带来巨大的冲击。\n\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n","tags":["精选"]},{"title":"第10期 Nginx 从入门到实践，万字详解 & JavaScript ES2020必知必会新特性","url":"/hotlink10/","content":"\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n\n[2020前端性能优化清单（五）](https://mp.weixin.qq.com/s?__biz=MzI5NjIzNjA1Nw==&mid=2247484186&idx=1&sn=f81d7a5e27422dfd253483ff29174bdb&scene=21#wechat_redirect)\n一份全面的性能优化指南\n\n[2020前端性能优化清单（六）](https://mp.weixin.qq.com/s?__biz=MzI5NjIzNjA1Nw==&mid=2247484187&idx=1&sn=f647d770ed17df9f29e7b2859b980250&scene=21#wechat_redirect)\n一份全面的性能优化指南\n\n[Nginx 从入门到实践，万字详解！](https://mp.weixin.qq.com/s?__biz=Mzg5ODA5MzQ2Mw==&mid=2247484653&idx=1&sn=3d384389337950a9f2391f2464bc4d9c&scene=21#wechat_redirect)\n最近越来越频繁地遇到需要配置反向代理的场景，在自己搭建博客的时候，也不可避免要用到 Nginx，所以这段时间集中学习了一下 Nginx，同时做了一些笔记，希望也可以帮助到大家～ 😜\n\n[前端性能优化之谈谈常见的性能指标及上报策略](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826819&idx=1&sn=825a07b6372143b353dcc3fb2208ac1e&scene=21#wechat_redirect)\n性能优化是所有前端人的追求，在这条路上，方法多种多样。这篇文章，说一下可以怎样定义性能指标及上报。\n\n[JavaScript ES2020必知必会新特性](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650591668&idx=1&sn=e67882ac4055e531ba0ee5cb67670b4b&scene=21#wechat_redirect)\n来看点新鲜的\n\n[第三题：无重复字符的最长子串 【leetcode】](https://mp.weixin.qq.com/s?__biz=MzI5NDY1MTk3Mg==&mid=2247485571&idx=1&sn=f07a0ee70b0e5eb67886ffc2074380b3&scene=21#wechat_redirect)\n有面试的小伙伴可以速览一波哟\n","tags":["精选"]},{"title":"第9期 来自阿里大佬的关于移动端体验优化经验总结 & 你连 HTTPS 原理都不懂，还讲“中间人攻击”？","url":"/hotlink9/","content":"\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n\n[2020前端性能优化清单（四）](https://mp.weixin.qq.com/s?__biz=MzI5NjIzNjA1Nw==&mid=2247484178&idx=1&sn=db9ce805b7eff5eec7cd93a259adfd88&scene=21#wechat_redirect)\n一份全面的性能优化指南\n\n[简析 Node.js 特点与应用场景](https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247485486&idx=2&sn=e2dffdc06cadeebcbf6b60aeaf146677&scene=21#wechat_redirect)\n如果你有一定的前端基础，比如 HTML、CSS、JavaScript、jQuery；那么，Node.js 能让你以最低的成本快速过渡成为一个全栈工程师(我称这个全栈为伪全栈，我认为的全栈也要精通数据库，不喜勿喷)，从而触及后端和移动端的开发。当然，Node.js也不是万能的、也不是说学了它就可以完全取代后端的其他开发语言，它有自己的使命和擅长的应用领域。\n\n[你连 HTTPS 原理都不懂，还讲“中间人攻击”？](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826808&idx=1&sn=091d9139f0400245eca5b37681812843&scene=21#wechat_redirect)\n随着 HTTPS 建站的成本下降，现在大部分的网站都已经开始用上 HTTPS 协议。大家都知道 HTTPS 比 HTTP 安全，也听说过与 HTTPS 协议相关的概念有 SSL 、非对称加密、 CA证书等，但对于以下灵魂三拷问可能就答不上了：\n\n[高效的编码：我的VS Code设置](https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&mid=2247485008&idx=1&sn=6e58bc74803d5d69b8979874de71864e&scene=21#wechat_redirect)\n代码编辑器很多，有些是免费的，有些是付费的。其中最喜欢的代码编辑器是 Visual Studio Code。它是免费的，并具有强大的功能，我陆续抛弃了Atom、Sublime Text以及也很强大的WebStorm。\n\n[来自阿里大佬的关于移动端体验优化经验总结](https://mp.weixin.qq.com/s?__biz=MzU3MDAyNDgwNA==&mid=2247485677&idx=1&sn=c5a013ce5d4c0b30816e014727978025&scene=21#wechat_redirect)\n很多企业都会特别注重自己产品的体验，尤其是移动端，那移动端的体验为什么这么重要？首先体验本身就很重要，好的体验带给用户的感受是截然不同的，用户选择使用一个产品除了产品本身功能满足需求之外，还有一个更重要的原因就是产品用起来“爽”，产品整个使用流程必然是舒适自然，才能受到大众喜爱；此外，产品体验已成为市场竞争力之一，借用人人都是产品经理上面对体验的论述：\n","tags":["精选"]},{"title":"第8期 2020前端性能优化清单（三）& 谈谈JS 的图片压缩","url":"/hotlink8/","content":"\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n\n[2020前端性能优化清单（三）](https://mp.weixin.qq.com/s?__biz=MzI5NjIzNjA1Nw==&mid=2247484177&idx=1&sn=bbc61b91a180bd2670233bf958afb9fc&scene=21#wechat_redirect)\n\n一份全面的性能优化清单\n\n[探索 Serverless 中的前端开发模式](https://mp.weixin.qq.com/s?__biz=MzA4Nzg0MDM5Nw==&mid=2247485006&idx=1&sn=cf2f367ef206c7432722bb949fae8184&scene=21#wechat_redirect)\n\n最近关于 Serverless 的讨论越来越多。看似与前端关系不大的 Serverless，其实早已和前端有了渊源，并且将对前端开发模式产生变革性的影响。本文主要就根据个人理解和总结，从前端开发模式的演进、基于 Serverless 的前端开发案例以及 Serverless 开发最佳实践等方面，与大家探讨 Serverless 中的前端开发模式。本人也有幸在 QCon2019 分享了这一主题。\n\n[一位阿里P7的面试经验分享](https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&mid=2247484840&idx=1&sn=cb511d3fbebaafc38a0a1edb9b268514&scene=21#wechat_redirect)\n\n今年二月以来，我的面试除了一个用友的，基本其他都被毙了，可以说是非常残酷的。其中有很多自己觉得还面的不错的岗位，比如百度、跟谁学、好未来等公司。说实话，打击比较大。\n\n[谈谈JS 的图片压缩](https://mp.weixin.qq.com/s?__biz=MzI0MzIyMDM5Ng==&mid=2649826806&idx=1&sn=c5e316f70abde478222a1e97972d9972&scene=21#wechat_redirect)\n\n说起图片压缩，大家想到的或者平时用到的很多工具都可以实现，例如，客户端类的有图片压缩工具 PPDuck3， JS 实现类的有插件 compression.js ，亦或是在线处理类的 OSS 上传，文件上传后，在访问文件时中也有图片的压缩配置选项，不过，能不能自己撸一套  JS 实现的图片压缩代码呢？当然可以，那我们先来理一下思路。\n","tags":["精选"]},{"title":"第7期 前端最佳实践之可维护性 & Flutter 2020春季更新 & Web上的图片技巧","url":"/hotlink7/","content":"\n### 前端收藏家（微信号: fedaily）\n##### 收集全网优秀前端技术资讯，与你分享，共同成长。\n\n[前端最佳实践之可维护性](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650591656&idx=1&sn=4e9bc80efcbd6415a28e48e9db77a930&scene=21#wechat_redirect)\n\n编写可维护的代码十分重要，因为很多开发者都会花大量时间去维护别人写的代码。实际开发中，从第一行代码开始写起的情况是非常少见的。通常都是要在别人的代码之上来构建自己的工作。让自己的代码容易维护，可以保证其他开发者更好地完成自己的工作。\n\n[【PPT】阿里@甑子：《前端智能化实践》——逻辑代码生成](https://mp.weixin.qq.com/s?__biz=MzIxNjgwMDIzMA==&mid=2247485422&idx=1&sn=d981f6cb327f70b17e1538c30828c367&scene=21#wechat_redirect)\n\n在第十四届D2前端技术论坛阿里高级前端技术专家@甄子做了《前端智能化实践》—逻辑代码生成的分享。\n\n[从 React 历史的长河里聊虚拟 DOM 及其价值](https://mp.weixin.qq.com/s?__biz=Mzg5NDEyMzA2NQ==&mid=2247485053&idx=1&sn=4c280d05cbe2857a1f74833b0515dd2a&scene=21#wechat_redirect)\n\n最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。\n\n[阿里盒马前端面试，你要的答案来了](https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247485475&idx=2&sn=8811928dc30b988e3e2c7f24604bb52e&scene=21#wechat_redirect)\n\n最近有一篇阿里盒马前端面试题被各大社区转载，而且据称这是阿里校招面试题，我看完以后，简直惊呆了，打死都不信。今天特意针对他们发的一面，把对应的答案整理了一些。\n\n[Web上的图片技巧](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651236377&idx=1&sn=4f6c04a5873d0f57fa2081b48c5e3f49&scene=21#wechat_redirect)\n\n在这篇文章中，我们将学习各种图片添加方式，以及每种方式的优缺点，以及什么时候和为什么要使用每种方式的上下文。\n\n[Flutter 2020春季更新](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247494345&idx=1&sn=e8d5a9516e721eb03e209f87df2b1f04&scene=21#wechat_redirect)\n\n谷歌 Flutter 项目的工程师、产品经理、UX 研究人员、技术撰稿人和开发关系工程师在过去几个月为这个项目付出了大量汗水和努力。他们在各种限制条件的制约下，使用各种公开可用的工具继续开发 2020 年的 Flutter 春季更新。如今，这一季度的更新已经准备就绪了。\n\n[在函数式编程中使用自定义React Hooks](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247494345&idx=2&sn=ec8882169c0de5c2a00e64c4da79bde0&scene=21#wechat_redirect)\n\n在本文中我决定走技术路线，分享我编写自定义 hooks 和集成某些函数式编程策略的经验。本文介绍了一个自定义 hook：useRecorder()。\n","tags":["精选"]},{"title":"JavaScript 原型、原型链概念理解","url":"/js-prototype/","content":"\n![](https://github.com/u9646/assets/blob/master/public/WeChatee3b7f703390054a53e5e450712f665f.png?raw=true)\n\n## 原型\n让我们从一张图开始。\n\n首先，我们看`Person`这个构造函数。它就是一个普通的函数：\n```\nfunction Person () {}\n```\n\n然后通过`new`操作符，我们可以生成一个实例：\n```\nvar person = new Person()\n```\n\n在我们定义了`Person`这个构造函数的时候，其实还生成了一个对象，这个对象就是原型对象。也就是图中的`Person.prototype`。它就是一个普通的对象。如果我们在控制台打印出来是这样的：\n```\n{\n  constructor: ƒ Person()\n  __proto__: Object\n}\n```\n\n它有一个`constructor`执行其构造函数。构造函数可以通过prototype属性访问原型。\n\n当我们使用`new`操作符创建了一个实例`person`的时候，通过还将这个实例同其构造函数的原型通过`__proto__`关联起来了。\n\n这就是构造函数、原型、实例三者的关系。也就是原型的概念。\n\n## 原型链\n\n从上面我们大概了解了原型的概念。那么什么是原型链呢？\n\n我们看`Person.prototype`。上面我们讲到，原型对象其实就是一个普通的对象，它有一个`constructor`属性指向其构造函数。它还有一个属性`__proto__`指向的是这个对象的原型。\n\n我们知道对象可以通过`Object`构造函数生成。就如同通过`Person`new一个`person`的实例，这个实例有一个属性`__proto__`指向`Person.prototype`一样。\n\n原型对象也是通过构造函数生成的。即`Object`。所以它也有一个`__proto__`属性指向其构造函数的原型，也就是`Object.prototype`。\n\n然后`Object.prototype`其实也是一个普通对象，只是它相比`Person.prototype`。它上面还有一些其他属性，我们打印一下看看：\n```\n{\n  constructor: ƒ Object()\n  __defineGetter__: ƒ __defineGetter__()\n  __defineSetter__: ƒ __defineSetter__()\n  hasOwnProperty: ƒ hasOwnProperty()\n  __lookupGetter__: ƒ __lookupGetter__()\n  __lookupSetter__: ƒ __lookupSetter__()\n  isPrototypeOf: ƒ isPrototypeOf()\n  propertyIsEnumerable: ƒ propertyIsEnumerable()\n  toString: ƒ toString()\n  valueOf: ƒ valueOf()\n  toLocaleString: ƒ toLocaleString()\n  get __proto__: ƒ __proto__()\n  set __proto__: ƒ __proto__()\n}\n```\n\n我们可以看到，它这里定义了`__proto__`属性的`getter/setter`。\n\n那么`Object.prototype.__proto__`是什么呢？通过控制台我们可以看到返回的是：`null`。\n\n到这里，我们其实以及可以看到，我们通过`Person`构造出来的`person`实例对象，通过`__proto__`属性，其实和`Object`关联了起来。\n\n而这样一个链条我们就称之为原型链。就是图中蓝色的线。\n\n那么原型链的作用是什么呢？\n\n我们还是通过上面的`person`实例来说明。如果我们在控制台尝试`person.toString()`。我们会发现会返回`[object Object]`。这里姑且先不说为什么返回这个，我们其实并没有定义`toString`方法，那么为什么可以调用呢？\n\n其实这里就是利用原型链的机制。当js在执行这句代码的时候，它会尝试在`person`上看有没有`toString`方法，如果没找到会去`Person.prototype`上查找。如果还是没找到，会去`Object.prototype`上查找，上面我们也打印出来，这上面是有`toString`方法的。所以`person.toString()`执行成功了，而不是报错，提示没有`toString`方法。\n\n通过原型链我们可以实现其他面向对象语言的继承的概念。\n\n## Function的原型是什么？\n通过控制台，我们可以看到：\n```\nfunction anonymous() {}\narguments: (...)\ncaller: (...)\nlength: 0\nname: \"\"\nconstructor: ƒ Function()\napply: ƒ apply()\nbind: ƒ bind()\ncall: ƒ call()\ntoString: ƒ toString()\nSymbol(Symbol.hasInstance): ƒ [Symbol.hasInstance]()\nget arguments: ƒ ()\nset arguments: ƒ ()\nget caller: ƒ ()\nset caller: ƒ ()\n__proto__: Object\n[[FunctionLocation]]: <unknown>\n[[Scopes]]: Scopes[0]\n```\n\n它其实是一个`anonymous`函数。并不是对一个普通对象。但是它同样有一个`__proto__`属性，指向了其原型，也就是`Object.prototype`。\n\n所有构造函数（除了通过bind,call返回的函数，以及箭头函数）都有一个`__proto__`属性指向`Function.prototype`。\n\n看开始的图，也就是`Person.__proto === Function.prototype`。`Object.__proto === Function.prototype`；\n\n包括其他的内置构造函数，比如`Number`, `String`等。\n\n所以也就有了`Function.__proto__ === Function.prototype`为`true`。这样的情况。我理解是这些其实是js语言内置的原型对象。和`Object.prototype`一样。首先是有了函数的原型，即`Function.prototype`。然后为了`Function`构造函数能够直接访问原型上的方法，所以将其`__proto__`属性指向了函数的原型。\n\n如果你执行`console.log(Number.prototype)`, `console.log(Date.prototype)`。你会发现都有一些区别，Number原型有一些特有函数的实现，Date也是如此。\n\n这些都是js内部实现的一些基础原型对象。\n","tags":["JavaScript"]},{"title":"CSP frame-ancestors 对比 X-Frame-Options","url":"/csp-frame-ancestors-vs-x-frame-options/","content":"\n> 这两个字段都是用于控制别的网站使用iframe或者frame加载你的网站的行为\n\n### X-Frame-Options\n该字段有三个可能的值，分别为`deny`,  `sameorigin`, `allow-from https://example.com/`；\n\n#### deny\n`deny`表示禁止任何使用iframe或者frame加载你的网站。\n\n#### sameorigin\n`sameorigin`表示只允许同源的网站使用iframe或者frame加载你的网站\n\n#### allow-from\n`allow-from`表示只允许该网站使用iframe或者frame加载你的网站。\n\n注意：强烈建议不要使用该属性，有两个问题：\n\n1. 浏览器兼容性很差，具体可参考 [MDN X-Frame-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options)\n2. 只能填写一个白名单地址\n\n以chrome v80 为例：\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/allow-from-test.png?raw=true)\n虽然allow-from写成了3100端口，但是页面依然加载出来了。经过测试，safari, firefox（和下面版本相同）都可以正常加载，说明它们都不支持该属性。\n\n#### 如何使用？\n\n> ***设置 meta 标签是无效的！例如 `<meta http-equiv=\"X-Frame-Options\" content=\"deny\">` 没有任何效果。不要这样用！只有当像下面示例那样设置 HTTP 头 X-Frame-Options 才会生效。***\n\n在请求头中增加`X-Frame-Options`例如：`X-Frame-Options: sameorigin`\n\n### CSP frame-ancestors\nCSP是指[Content-Security-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)。\n\n`frame-ancestors`是其中一个指令。指定了一个可以包含`<frame>`，`<iframe>`，`<object>`，`<embed>`，or `<applet>`等元素的有效父级。\n\n> ***该指令不支持通过<meta> 元素或通过 `Content-Security-policy-Report-Only` 头域所指定.***\n\n当`frame-ancestors`设为`none`时，作用类似于`X-Frame-Options: deny`。\n\n`frame-ancestors`策略可以设置一个或多个源`<source>`：\n\n#### `<host-source>`\n主机的名称或IP地址，以及一个可选的URL scheme和／或端口号\n\n例如：\n* http://*.example.com: 匹配所有使用http:URL scheme并来对于example.com及其子域名的加载意图。\n* mail.example.com:443: 匹配所有对于mail.example.com在443端口的访问意图。\n* https://store.example.com: 匹配所有使用https:访问store.example.com的意图。\n\n#### `<scheme-source>`\n一个schema配置，比如'http:'或'https:'。注意，冒号是必要的。你同样也可以指定一个data schema（但并不推荐）。\n\n例如：\n* 'data:' 允许 data: URIs 作为内容源。 这是不安全的，攻击者可以用此来注入恶意代码。请谨慎使用，并不要令其作用于脚本。\n* 'mediastream:' 允许 mediastream: URIs 作为内容源.\n* 'blob:' 允许 blob: URIs 作为内容源.\n* 'filesystem:' 允许 filesystem: URIs 作为内容源.\n\n#### self\n指向一个该受保护文档所在的源，包含同样的URL schema和端口号。必须用单引号设置。有些浏览器会从源指令中排除blob和filesystem。需要允许这些内容类型的站点可以通过Data属性指定它们。\n\n例如：`Content-Security-Policy: frame-ancestors 'self'`\n\n#### none\n指向一个空集，意味着没有URL会被匹配。也需要单引号包裹设置。\n例如：`Content-Security-Policy: frame-ancestors 'none'`\n\n可以同时配置多个规则：\n`Content-Security-Policy: frame-ancestors 'self' https://example.com`\n\n\n### 结论\n当你只需要配置不允许别人使用iframe加载你的网站或者只允许同源网站的时候，使用X-Frame-Options即可。如果你需要使用白名单的方式控制其行为，那么你应该使用`Content-Security-Policy: frame-ancestors`，它支持配置多个白名单而且具有更好的浏览器兼容性。\n\n当他们同时设置的时候，按规范`Content-Security-Policy: frame-ancestors`具有更高的优先级。但是现实往往不是如此，很多浏览器对此行为比不一致。建议只设置一个配置。\n\n#### 测试：\n> 这里以mac上面的几个常用浏览器为例，需要的小伙伴可以使用express自己在本地进行测试。\n\n比如请求头同时有以下两个配置:\n`Content-Security-Policy: frame-ancestors 'self' https://example.com`\n`X-Frame-Options: sameorigin`\n##### chrome v80\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/both-csp-xframe.png?raw=true)\n可以看到chrome是可以正常加载的\n\n##### safari v12\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/both-csp-xframe-safari.png?raw=true)\n可以看到safari先判断了x-frame-options，然后就阻止了页面加载。\n\n##### firefox v73\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/both-csp-xframe-firefox.png?raw=true)\n可以看到火狐也是可以正常加载了\n","tags":["安全"]},{"title":"技术精选 - 第3期","url":"/hotlink-3/","content":"\n[最常见的6种Web应用漏洞及解决方案](https://mp.weixin.qq.com/s/M-O_Yv1-2Rfcw0scjxoRLQ)\nWeb应用基于C/S（Client/Server）服务模型搭建：客户端发送请求，服务端负责响应。一般客户端就是浏览器，但可以向服务器发送请求的软件则远远不限于浏览器。Web服务器通常以公开的域名接收请求并提供服务，需要应对任何来源的请求。\n\n[ARIA 实践指南](https://mp.weixin.qq.com/s/s9xVdhfswKk8x3qVXik3Hw)\nARIA 属于可访问性语义的范畴。从功能上来说，ARIA 的 roles、states 和 properties 类似于辅助技术的 CSS。对屏幕阅读器而言，ARIA 控制着它们的非视觉体验的渲染。\n\n[纯前端JS zip打包文件并下载](https://www.zhangxinxu.com/wordpress/2019/08/js-zip-download/?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)\n如何实现ZIP打包下载\n\n[浅谈React性能优化的方向](https://mp.weixin.qq.com/s/WwKwX6HzT5HHxsGyx1YM1Q)\nReact 渲染性能优化的三个方向，其实也适用于其他软件开发领域，这三个方向分别是:减少计算的量,利用缓存,精确重新计算的范围\n\n[浅谈 Webpack 背后的运行机制](https://mp.weixin.qq.com/s/GQ4hJm7UPv2kcyh9-tW2aQ)\n在平时开发中我们经常会用到 Webpack这个时下最流行的前端打包工具。它打包开发代码，输出能在各种浏览器运行的代码，提升了开发至发布过程的效率。\n\n[你所不知道的 CSS 负值技巧与细节](https://mp.weixin.qq.com/s/GpcuCf9qZfJaotGluR-zXQ)\n写本文的起因是，一天在群里有同学说误打误撞下，使用负的 outline-offset 实现了加号。嗯？好奇的我马上也动手尝试了下，到底是如何使用负的 outline-offset 实现加号呢？\n\n[深度理解 React Suspense](https://mp.weixin.qq.com/s/ygVL3y-ElcNQosXbhs-k2w)\n在 16.6 版本之前，code-spliting 通常是由第三方库来完成的，比如 react-loadble(核心思路为: 高阶组件 + webpack dynamic import), 在 16.6 版本中提供了 Suspense 和 lazy 这两个钩子, 因此在之后的版本中便可以使用其来实现 Code Spliting。\n\n[Node.js 高级进阶之 fs 文件模块学习](https://mp.weixin.qq.com/s/vYWdALZ8DGpa9HNPOKkjTg)\n文件操作是开发过程中并不可少的一部分，作为一名 Node.js 开发工程师更应该熟练掌握fs模块的相关技巧。Node.js 中的 fs 模块是文件操作的封装，它提供了文件读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其它模块不同的是，fs 模块中所有的操作都提供了异步和同步的两个版本,具有 sync 后缀的方法为同步方法，不具有 sync 后缀的方法为异步方法\n","tags":["精选"]},{"title":"HTTP三次握手和四次挥手","url":"/http-three-way-handshake-and-wave-four-times/","content":"\n## 三次握手\n> 三次握手是指客户端在和服务端建立tcp连接的时候需要进行三次通信，然后才能完成连接。\n\n![image](https://upload-images.jianshu.io/upload_images/2179059-169363549c8e9f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这三次通信分别是:\n\n1. 客户端向服务端发送一个数据包，告诉服务端需要建立连接;\n2. 服务端收到客户端发送的数据包之后，会返回一个数据包，通知客户端，我已经收到你的连接请求;\n3. 客户端收到服务端返回的信息后，知道服务端已经准备好建立连接，但是还需要再发送一个数据包给服务端，用于告诉服务端我已经收到你的回复了。\n\n这个时候，连接就已经建立了。双方可以进行数据传输了。\n\n### 为什么一定需要三次连接呢?\n主要还是因为存在数据可能丢失的问题，也就是说不管是客户端或者服务端，都不能确定自己发出的信息对方有没有正常接收到，所以需要对方发送一个回复信息。用于确定自己发出的信息已经被对方正常接收。\n\n### 双方是如何确认对方的呢?\n比如服务端可能会同时接收多个客户端的连接请求，它是如何区分不同客户端的呢？答案就是随机值。\n\n客户端在第一次握手的时候，会生成一个随机数(j)，和数据包一起发送给服务端;\n\n第二次握手的时候，服务端会将这个随机值+1(j+1)，同时服务端也生成一个随机值(k)一起再返回给客户端;\n\n第三次握手的时候，客户端会检验j+1的值，如果检验通过，会将k+1，然后发送给服务端，服务端检验k+1的值，检验通过以后，连接就建立了。\n\n当然，实际的tcp连接中，数据包不只是包含随机值，同时还有各种标志位用于确认请求。\n\n### SYN攻击\n在三次握手过程中，当服务端发送SYN-ACK之后收到客户端的ACK之前的状态称为半连接状态，如果服务端一直没有收到客户端的ACK包，服务端需要不断重发直到超时。SYN攻击就是客户端在短时间内大量伪造不存在的ip地址，向服务端发起连接请求，由于源地址不存在，服务端一直不能收到客户端返回的ACK包，导致网络堵塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，如果服务端有大量半连接状态且源ip地址是随机的，则可以判断遭到SYN攻击。可以使用：\n\n```shell\n#netstat -nap | grep SYN_RECV\n```\n\n\n## 四次挥手\n> 四次挥手是指断开TCP连接时，需要客户端和服务端总共发送4次数据包以确认连接的断开\n\n![image.png](https://upload-images.jianshu.io/upload_images/2179059-9b09667fe6b27de1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由于TCP连接是全双工的，因此，每个方向都需要单独进行关闭。这一原则是指当一方完成数据传输任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只意味着这一方向上没有数据传输，但在这个TCP连接上仍然能够发送数据，直到这一方向也发送FIN来。\n\n首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。\n\n1. 第一次挥手：client发送一个FIN，用来关闭client到server的数据传输，client进入FIN_WAIT_1状态；\n2. 第二次挥手：server收到FIN后，发送一个ACK给client，确认序号为收到序号+1，server进入CLOSE_WAIT状态；\n3. 第三次挥手：server发送一个FIN，用来关闭server到client的数据传输，server进入LAST_ACK状态；\n4. 第四次挥手：client收到FIN后，client进入TIME_WAIT状态，接着发送一个ACK给server，确认序号为收到序号+1，server进入CLOSE状态。\n\n完成四次挥手。\n\n### 为什么关闭连接需要四次挥手呢？\n这是因为当收到对方的FIN报文时，仅仅表示对方不再发送数据了，但是还能接收数据。己方也未必全部将数据都发送给对方了，所以己方可以立即CLOSE，也可以发送一个数据给对方后，再发送FIN报文给对方表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。\n\n### 为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能返回到CLOSE状态？\n\n原因有二：\n\n1. 保证TCP协议的全双工连接能够可靠关闭；\n2. 保证这次连接的重复数据段从网络中消失。\n\n先说第一点，如果client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致server没有收到client最后回复的ACK。那么server就会在超时之后继续发送FIN，此时由于client已经CLOSED了，就找不到与重发的FIN对应的连接，最后server就会收到RST而不是ACK，server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。\n\n再说第二点，如果client直接CLOSED，然后又再向server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。\n","tags":["HTTP"]},{"title":"HTTP缓存之协商缓存和强制缓存","url":"/http-cache/","content":"\n通常根据是否需要向服务器重新发起HTTP请求去确认缓存是否有效将缓存分为强制缓存和协商缓存\n\n## 强制缓存\n`强制缓存`就是直接从浏览器缓存查找该结果，并根据结果的缓存规则来决定是否使用该缓存的过程。\n\n* 不存在该缓存结果和标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）\n* 存在缓存结果和标识，但结果已失效，强制缓存失效，则使用协商缓存\n* 存在缓存结果和标识，并且结果未失效，强制缓存生效，直接返回该结果\n\n控制强制缓存的字段分别是`Expires`和`Cache-Control`，其中`Cache-Control`优先级比`Expires`高。\n\n### Expires\n\n`Expires`是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于`Expires`的值时，直接使用缓存结果。\n\n#### `Expires`是HTTP/1.0的字段，但现在浏览器默认使用HTTP/1.1，那么HTTP/1.1中网页缓存是否还是由`Expires`控制？\n\n到了HTTP/1.1，`Expires`已经被`Cache-Control`替代，原因在于`Expires`控制缓存的原理是使用客户端的时间和服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区）发送误差，那么强制缓存则会直接失效。\n\n### Cache-Control\n在HTTP/1.1中，`Cache-Control`是最重要的规则，主要用于控制网页缓存，主要取值为：\n\n* `public`：所有内容都将被缓存（客户端/代理服务器/CDN等）\n* `private`：只有客户端可以缓存，`Cache-Control`默认值\n* `no-cache`：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n* `no-store`：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n* `max-age=xxx`：缓存将在xxx秒后失效\n\n> `Cache-Control/Expires`同时存在时，只有`Cache-Control`生效\n\n## 协商缓存\n`协商缓存`就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：\n\n1. 协商缓存生效，返回304，服务器告诉浏览器资源未更新，则再去浏览器缓存中访问资\n源\n2. 协商缓存失效，返回200和请求结果\n\n同样，协商缓存的标识也是在响应报文的HTTP头和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：\n\n* `Last-Modified/If-Modified-Since`\n* `Etag/If-None-Match`\n\n其中`Etag/If-None-Match`优先级比`Last-Modified/If-Modified-Since`高\n\n### Last-Modified/If-Modified-Since\n`Last-Modified`是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。\n\n`If-Modified-Since`则是客户端再次发起该请求时，携带上次请求返回的`Last-Modified`值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有`If-Modified-Since`字段，则会根据`If-Modified-Since`的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后修改时间大于`If-Modified-Since`的字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可以继续使用缓存文件。\n\n### Etag/If-None-Match\n`Etag`是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）。\n\n`If-None-Match`是客户端再次发起请求时，携带上次请求返回的唯一标识Etag值，服务端收到该请求后，发现该请求含有`If-None-Match`，则会根据`If-None-Match`的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件，否则重新返回资源，状态码为200.\n\n## 总结\n`强制缓存`优先于`协商缓存`，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。\n","tags":["HTTP"]},{"title":"技术精选 - 第2期","url":"/hotlink-2/","content":"\n[具有“脚本魔力”的属性们](https://mp.weixin.qq.com/s/8znEKWxCahJE1zSf9Zky_Q)\n属性的“脚本魔力”，是指仅仅通过一行简单的属性设置，就能实现看起来要 JS 才能完成的交互功能。包括但不限于\n\n[完全理解 redux（从零实现一个 redux）](https://mp.weixin.qq.com/s/jfDrhX6jMr36dRaFCH9Xbw)\n记得开始接触 react 技术栈的时候，最难理解的地方就是 redux。全是新名词：reducer、store、dispatch、middleware 等等，我就理解 state 一个名词。\n\n[用 Service Worker 实现前端性能优化](https://mp.weixin.qq.com/s/SLG_cDxDo7BaoQqAyLGa-Q)\n说起前端性能优化, 我们首先想到的可能就是用 Gulp 、Webpack 之类的自动化构建工具对 HTML、CSS 、JS 代码进行压缩，同时优化图片资源。再者就是使用 CSS Sprite 或者对于较小的图片用 base64 直接编码来进行优化。当然还有很多可以优化的方向，例如考虑浏览器缓存、页面渲染性能 ( 减少重排与重绘与 GPU 硬件加速 ) 、JS阻塞性能等等。但我们今天讲的是如何利用缓存策略在适宜的情况下直接减少对前端数据的请求量从而达到前端性能的优化。因此 Service Worker 以及其相关的 API 就成为了我们今天的主角。\n\n[TypeScript 技巧拾遗](https://mp.weixin.qq.com/s/pMGOecpnploICBqoAAg9fQ)\n很早以前就尝试过使用 TypeScript 来进行日常编码，但自己对静态类型语言的了解并不深入，再加上 TypeScript 的类型系统有着一定的复杂度，因此感觉自己并没有发挥好这门语言的优势，使代码变得更具可读性与可维护性。于是这几天便想着好好研究下这门语言，希望能够总结出一些特别的语言特性与实用技巧。\n\n[从零开始写一个符合Promises/A+规范的promise](https://mp.weixin.qq.com/s/JMnJUCVLMX15mTkIe4U6lQ)\n本篇主要讲解如何从零开始一步步的实现promise各项特性及功能，最终使其符合Promises/A+规范，因为讲解较细，所以文章略长。另外，每一步的项目源码都在github上，可以对照参考，每一步都有对应的项目代码及测试代码，喜欢的话，欢迎给个star~\n\n[「手摸手设计模式系列」享元模式与资源池](https://mp.weixin.qq.com/s/sPVuiUTOvu1KsRwEOhMQ2g)\n享元模式 （Flyweight Pattern）运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。\n\n[前端中的编译原理 - 从零打造一个实用的 Babel 插件](https://mp.weixin.qq.com/s/XSzQ5nkLI369CDhMZtF-MQ)\n说起编译原理，可能我们脑海中首先浮现的就是 “编译器” 这个词汇。维基百科上对编译器的定义是：编译器是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。 通常一个编译器的编译过程会经过词法分析、语法分析、语义分析、生成中间代码、优化、生成目标代码这几个阶段。如果将其简要概括，则只包含 解析 ( parse ) 、转换 ( transform ) 、生成 ( generate ) 这三个阶段。\n\n[前端工程师需要了解的 Babel 知识](https://mp.weixin.qq.com/s/zQ5kCgoUbTOTqARI5o2cBQ)\n在前端圈子里，对于 Babel，大家肯定都比较熟悉了。如果哪天少了它，对于前端工程师来说肯定是个噩梦。Babel 的工作原理是怎样的可能了解的人就不太多了。\n","tags":["精选"]},{"title":"mongodb Query 和 Projection 常用操作符","url":"/mongodb-query-and-projection-operators/","content":"\n> [文档链接](https://docs.mongodb.com/manual/reference/operator/query/)\n\n## 比较运算符\n\n### $eq\n`{ <field>: { $eq: <value> } }`\n选择：等于某个值\n\n### $gt\n`{field: {$gt: value} }`\n选择：大于某个值\n\n### $gte\n`{field: {$gte: value} }`\n选择：大于等于某个值\n\n### $in\n`{ field: { $in: [<value1>, <value2>, ... <valueN> ] } }`\n选择：\n1. filed是一个值，并且等于value1 or value2 ...\n1. field是个数组，并且filed中至少存在某个值等于value1 or value2 ...\n\n### $lt\n`{field: {$lt: value} }`\n选择：小于某个值\n\n### $lte\n`{ field: { $lte: value} }`\n选择：小于等于某个值\n\n### $ne\n`{field: {$ne: value} }`\n\n选择：\n1. field不等于某个值\n2. field不存在\n\n### $nin\n`{ field: { $nin: [ <value1>, <value2> ... <valueN> ]} }`\n\n选择：\n1. field值不存在于数组中\n2. field不存在\n\n## 逻辑运算符\n### $and\n`{ $and: [ { <expression1> }, { <expression2> } , ... , { <expressionN> } ] }`\n\n选择同时匹配所有expression的数据\n\n> 如果expression1为false，则mongodb不会继续后续的判断\n\n### $not\n`{ field: { $not: { <operator-expression> } } }`\n\n选择所有不符合operator-expression的数据。\n\n```\n// 选择所有price小于等于1.99或者price字段不存在的数据\ndb.inventory.find( { price: { $not: { $gt: 1.99 } } } )\n```\n\n### $nor\n`{ $nor: [ { <expression1> }, { <expression2> }, ...  { <expressionN> } ] }`\n\n选择同时不满足所有expression的数据\n\n### $or\n`{ $or: [ { <expression1> }, { <expression2> }, ... , { <expressionN> } ] }`\n\n选择至少满足一个expression的数据\n\n## 元素运算符\n### $exists\n`{ field: { $exists: <boolean> } }`\n\n选择filed是否存在的数据，$exists: true代表存在，false代表不存在\n\n### $type\n`{ field: { $type: <BSON type> } }`\n选择filed是某个具体类型的实例的数据，可以写具体type或者对应数字\n\n具体BSON type可以看文档：https://docs.mongodb.com/manual/reference/operator/query/type/#document-type-available-types\n\n## 数组运算符\n### $all\n`{ <field>: { $all: [ <value1> , <value2> ... ] } }`\n\n选择filed是个数组，并且包含所有value1 and value2 ...\n\n### $elemMatch\n`{ <field>: { $elemMatch: { <query1>, <query2>, ... } } }`\n\n选择filed是个数组并且至少有一个元素满足query1 or query2 ...\n\n> 如果query只有一个，那么你不需要使用$elemMatch\n\n### $size\n`db.collection.find( { field: { $size: 2 } } );`\n\n选择filed数组长度等于某个值的数据\n\n## projection运算符\n\n### $\n```\n// 示例数据\n{ \"_id\" : 1, \"semester\" : 1, \"grades\" : [ 70, 87, 90 ] }\n{ \"_id\" : 2, \"semester\" : 1, \"grades\" : [ 90, 88, 92 ] }\n{ \"_id\" : 3, \"semester\" : 1, \"grades\" : [ 85, 100, 90 ] }\n{ \"_id\" : 4, \"semester\" : 2, \"grades\" : [ 79, 85, 80 ] }\n{ \"_id\" : 5, \"semester\" : 2, \"grades\" : [ 88, 88, 92 ] }\n{ \"_id\" : 6, \"semester\" : 2, \"grades\" : [ 95, 90, 96 ] }\n\n// 只返回grades数组的第一个元素\ndb.students.find( { semester: 1, grades: { $gte: 85 } },\n                  { \"grades.$\": 1 } )\n// 结果为：\n{ \"_id\" : 1, \"grades\" : [ 87 ] }\n{ \"_id\" : 2, \"grades\" : [ 90 ] }\n{ \"_id\" : 3, \"grades\" : [ 85 ] }\n\n// { \"grades.$\": 1 } 这里的1只是代表显示grades字段\n```\n\n### $elemMatch\n用于控制数据返回值，只会显示某个字段第一个满足$elemMatch的元素\n\n```\n// 示例数据\n{\n _id: 1,\n zipcode: \"63109\",\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: \"63110\",\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: \"63109\",\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: \"63109\",\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n              { name: \"ruth\", school: 102, age: 16 },\n           ]\n}\n\ndb.schools.find( { zipcode: \"63109\" },\n                 { students: { $elemMatch: { school: 102 } } } )\n// 结果为：\n{ \"_id\" : 1, \"students\" : [ { \"name\" : \"john\", \"school\" : 102, \"age\" : 10 } ] }\n{ \"_id\" : 3 }\n{ \"_id\" : 4, \"students\" : [ { \"name\" : \"barney\", \"school\" : 102, \"age\" : 7 } ] }\n\n\n\ndb.schools.find( { zipcode: \"63109\" },\n                 { students: { $elemMatch: { school: 102, age: { $gt: 10} } } } )\n// 结果为：\n{ \"_id\" : 1, \"students\" : [ { \"name\" : \"jess\", \"school\" : 102, \"age\" : 11 } ] }\n{ \"_id\" : 3 }\n{ \"_id\" : 4, \"students\" : [ { \"name\" : \"ruth\", \"school\" : 102, \"age\" : 16 } ] }\n```\n\n### $slice\n`db.collection.find( { field: value }, { array: {$slice: count } } )`\n\n用于控制某个数组字段返回多少个元素\n\n```\n// 返回comments前5个元素\ndb.posts.find( {}, { comments: { $slice: 5 } } )\n\n// 返回最后5个元素\n//db.posts.find( {}, { comments: { $slice: -5 } } )\n```\n\n$slice还可以是个数组，即[skip, limit]，表明跳到第skip个元素，从这里选择limit个。\n\n```\n// 跳过前20个元素，然后开始往后选择10个\ndb.posts.find( {}, { comments: { $slice: [ 20, 10 ] } } )\n\n// 从倒数第20个元素开始，往后选择10个元素\ndb.posts.find( {}, { comments: { $slice: [ -20, 10 ] } } )\n```\n\n还有一些其他操作符，可以参考文档。\n","tags":["mongodb"]},{"title":"技术精选 - 第1期","url":"/hotlink-1/","content":"\n[网站性能指标这么多，你到底选对了吗](https://mp.weixin.qq.com/s/ITb0IWzLPj715NUgL7C4HA)\n从用户体验角度来看一个网址或者app是否有吸引力，75%的人是认为页面加载时长是一个核心因素，远远高于其他影响用户体验的问题，例如：简洁易用、屏幕适配、设计吸引力等等。\n\n[npm install 原理分析](https://mp.weixin.qq.com/s/byX6V6fL9O1SuEdppZO2CA)\n开门见山，npm install 大概会经过上面的几个流程，本篇文章来讲一讲各个流程的实现细节、发展以及为何要这样实现。\n\n[Webpack 插件开发如此简单！](https://mp.weixin.qq.com/s/nimOuftziXCWHV61FfjWog)\n本文将带你一起开发第一个 Webpack 插件，从 Webpack 配置工程师，迈向 Webpack 开发工程师！\n\n[让你牛B加身的前端必会Linux命令](https://mp.weixin.qq.com/s/80UEbeEfPBV2LMmRqJFT7w)\n本文主要针对于 FEer 们。作为前端，一开始我们总是和 HTML/JavaScript/CSS 三大块打交道，但是久而久之，我们就会接触更多的内容，比如服务的部署。而这一块对于我们的要求会更全面，其中对 Linux 指令就有很多要求。如果你想要部署服务，而又没有成熟的工具或平台可以借助，需要完全自己来操作的话，你就需要准备好部署服务需要的所有文件、登录指定的服务器、发布指定文件、启动服务、服务器启动不成功时候进行调试以及服务维护过程中进行问题的排查。本文就将从这一条线讲起，分享歪马在工作中所积累的一些实用指令。\n\n[给你梳理了 44 个 CSS 精选知识点](https://mp.weixin.qq.com/s/Pw3VgFpijTYRkJyYPvlJgA)\n一个周五的晚上，闲来无事整理下自己的 github（经常做收藏党），今天打算都过一遍，发现一个 star很高的项目，里面有大量的 CSS 片段，而且标题很诱人，然后又花了将近1个小时从头到尾过了一遍，其中一些是我们常用的一些知识点，另外也包含一些比较新的属性的应用，知识点挺多的，为了让大家看起来更方便些，然后又花了点（很长很长）时间翻译成中文。\n\n[你必须懂的前端性能优化](https://mp.weixin.qq.com/s/DdbaiuZd4RbqUod0jhn_vg)\n从输入 URL 到页面加载完成的过程：\n\n首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来\n 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n\n[深入理解 JavaScript 原型](https://mp.weixin.qq.com/s/qg9LNm3awHBao1Du5n6KMQ)\nPrototype 是 JavaScript 里的一个基础概念，原本应该很容易理解。然而，出于各种原因，大部分前端开发者（包括我），在刚开始学习 JS 时，原型和原型链都是一个需要克服的困难。\n\n[Promise 链式调用顺序引发的思考](https://mp.weixin.qq.com/s/zTVRIwmA_9oQ-Ea_b1oqqA)\n近一个多月没有写博客了，前阵子一个朋友问我一个关于 Promise 链式调用执行顺序的问题\n","tags":["精选"]},{"title":"mongodb 增删改查CURD基本操作总结","url":"/mongodb-curd-api/","content":"\n> 基于[mongodb v4.2](https://docs.mongodb.com/manual/introduction/)\n\n## 插入数据\n\n### 插入一条数据\n`db.collection.insertOne()` 插入一个文档到集合中\n\n```\ntry {\n   db.products.insertOne( { item: \"card\", qty: 15 } );\n} catch (e) {\n   print (e);\n};\n// 返回值：\n{\n   \"acknowledged\" : true,\n   \"insertedId\" : ObjectId(\"56fc40f9d735c28df206d078\")\n}\n```\n\n### 插入多条数据\n`db.collection.insertMany()` 同时插入多条数据到集合中\n\n```\ntry {\n   db.products.insertMany( [\n      { item: \"card\", qty: 15 },\n      { item: \"envelope\", qty: 20 },\n      { item: \"stamps\" , qty: 30 }\n   ] );\n} catch (e) {\n   print (e);\n}\n// 返回值：\n{\n   \"acknowledged\" : true,\n   \"insertedIds\" : [\n      ObjectId(\"562a94d381cb9f1cd6eb0e1a\"),\n      ObjectId(\"562a94d381cb9f1cd6eb0e1b\"),\n      ObjectId(\"562a94d381cb9f1cd6eb0e1c\")\n   ]\n}\n```\n\ninsert 特性：\n如果当前集合不存在，会自动创建一个集合。\n\n_id 属性：\nmongodb里面，如果你不提供_id，mongodb会默认在插入文档的时候为每一个文档创建一个唯一的_id，作为主键\n\n\n## 查找数据\nmongodb可以使用`find`方法查找数据\n\n### 普通查询\n\n> 每个文档插入到集合中如果不提供一个_id字段，则mongodb会自动生成一个，并且在查询语句中默认返回，这里省略没有显示该字段\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"A\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" }\n]);\n```\n\n```\n// 查找 size 等于 { h: 14, w: 21, uom: \"cm\" } 的数据\ndb.inventory.find( { size: { h: 14, w: 21, uom: \"cm\" } } )\n// or 查找 qty 等于 25 的数据\ndb.inventory.find({ qty: 25 })\n// or 使用嵌套查询 size 的 uom 等于 in 的数据\ndb.inventory.find( { \"size.uom\": \"in\" } )\n// $lt 小于\ndb.inventory.find( { \"size.h\": { $lt: 15 } } )\n// 复合条件查询，查询 size.h 小于 15， 并且 size.uom 等于 in，并且 status 等于 D 的数据\ndb.inventory.find( { \"size.h\": { $lt: 15 }, \"size.uom\": \"in\", status: \"D\" } )\n```\n\n### 查询数组\n```\n// 示例数据\ndb.inventory.insertMany([\n   { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"], dim_cm: [ 14, 21 ] },\n   { item: \"notebook\", qty: 50, tags: [\"red\", \"blank\"], dim_cm: [ 14, 21 ] },\n   { item: \"paper\", qty: 100, tags: [\"red\", \"blank\", \"plain\"], dim_cm: [ 14, 21 ] },\n   { item: \"planner\", qty: 75, tags: [\"blank\", \"red\"], dim_cm: [ 22.85, 30 ] },\n   { item: \"postcard\", qty: 45, tags: [\"blue\"], dim_cm: [ 10, 15.25 ] }\n]);\n```\n\n```\n// 查询 tags 等于 [\"red\", \"blank\"] 的数据\ndb.inventory.find( { tags: [\"red\", \"blank\"] } )\n\n// 或者你想查询tags包含 red blank，不管它的顺序，或者是否还有其他元素，你可以使用 `$all`\ndb.inventory.find( { tags: { $all: [\"red\", \"blank\"] } } )\n\n// 查询tags 里面包含 red的数据\ndb.inventory.find( { tags: \"red\" } )\n\n// 查询dim_cm里面最少有一个值大于 25\ndb.inventory.find( { dim_cm: { $gt: 25 } } )\n\n/*\n** 查询dim_cm里面:\n** 1. 有一个元素同时满足大于15并且小于20\n** 2. 有两个分别满足小于15以及大于20\n*/\ndb.inventory.find( { dim_cm: { $gt: 15, $lt: 20 } } )\n// 所以结果是返回这四条：\n{ \"item\" : \"journal\", \"qty\" : 25, \"tags\" : [ \"blank\", \"red\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"notebook\", \"qty\" : 50, \"tags\" : [ \"red\", \"blank\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"paper\", \"qty\" : 100, \"tags\" : [ \"red\", \"blank\", \"plain\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"postcard\", \"qty\" : 45, \"tags\" : [ \"blue\" ], \"dim_cm\" : [ 10, 15.25 ] }\n\n// 查询dim_cm里面至少有一个元素同时满足大于22并且小于30的数据\ndb.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } )\n\n// 查询dim_cm第二个元素大于25的数据\ndb.inventory.find( { \"dim_cm.1\": { $gt: 25 } } )\n\n// 查询dim_cm的tags数组长度为3的数据\ndb.inventory.find( { \"tags\": { $size: 3 } } )\n```\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", instock: [ { warehouse: \"A\", qty: 5 }, { warehouse: \"C\", qty: 15 } ] },\n   { item: \"notebook\", instock: [ { warehouse: \"C\", qty: 5 } ] },\n   { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 15 } ] },\n   { item: \"planner\", instock: [ { warehouse: \"A\", qty: 40 }, { warehouse: \"B\", qty: 5 } ] },\n   { item: \"postcard\", instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] }\n]);\n\n// 查询instock数组里面有一个元素为{ warehouse: \"A\", qty: 5 }的数据，必须warehouse等于A并且qty等于5，包括顺序也必须一致\ndb.inventory.find( { \"instock\": { warehouse: \"A\", qty: 5 } } )\n\n// 查询instock数组里面至少有一个元素的qty字段值小于等于20的数组\ndb.inventory.find( { 'instock.qty': { $lte: 20 } } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"notebook\", \"instock\" : [ { \"warehouse\" : \"C\", \"qty\" : 5 } ] }\n{ \"item\" : \"paper\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 60 }, { \"warehouse\" : \"B\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n{ \"item\" : \"postcard\", \"instock\" : [ { \"warehouse\" : \"B\", \"qty\" : 15 }, { \"warehouse\" : \"C\", \"qty\" : 35 } ] }\n\n// 查询instock数组的第一个元素的qty字段小于等于20的数据\ndb.inventory.find( { 'instock.0.qty': { $lte: 20 } } )\n\n// 查询instock数组里至少有一个元素同时满足qty等于5并且warehouse等于A的数组\ndb.inventory.find( { \"instock\": { $elemMatch: { qty: 5, warehouse: \"A\" } } } )\n\n// 查询instock数组里至少有一个元素的qty同时满足大于10并且小于等于20\ndb.inventory.find( { \"instock\": { $elemMatch: { qty: { $gt: 10, $lte: 20 } } } } )\n\n// 查询instock数组里至少有一个元素满足大于10或者小于等于20\ndb.inventory.find( { \"instock.qty\": { $gt: 10,  $lte: 20 } } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"paper\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 60 }, { \"warehouse\" : \"B\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n{ \"item\" : \"postcard\", \"instock\" : [ { \"warehouse\" : \"B\", \"qty\" : 15 }, { \"warehouse\" : \"C\", \"qty\" : 35 } ] }\n\n// 查询instock里任意一个元素的qty等于5并且任意一个元素的warehouse等于A的数据\ndb.inventory.find( { \"instock.qty\": 5, \"instock.warehouse\": \"A\" } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n```\n\n### 控制查询语句输出结果\n默认情况下，查询语句会返回文档的所有字段，我们可以通过第二个参数来自定义返回文档里的哪些字段\n\n关于第一个参数，我们这里就不详细说明了，可参考上面\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n  { item: \"journal\", status: \"A\", size: { h: 14, w: 21, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 5 } ] },\n  { item: \"notebook\", status: \"A\",  size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"C\", qty: 5 } ] },\n  { item: \"paper\", status: \"D\", size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"A\", qty: 60 } ] },\n  { item: \"planner\", status: \"D\", size: { h: 22.85, w: 30, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 40 } ] },\n  { item: \"postcard\", status: \"A\", size: { h: 10, w: 15.25, uom: \"cm\" }, instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] }\n]);\n\n// 返回所有文档的status为的A的数据的所有字段\ndb.inventory.find( { status: \"A\" } )\n\n// 只返回文档的item, status字段以及_id（默认显示），1代表显示，0则是不显示\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1 } )\n\n// 如果想要_id也不返回，可以这样：\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, _id: 0 } )\n\n// 也可以单独给某些不想显示的字段设为0，其余的正常显示\ndb.inventory.find( { status: \"A\" }, { status: 0, instock: 0 } )\n\n// 还可以控制嵌套对象的字段，下面语句只显示_id, item, status, 以及size的uom字段\ndb.inventory.find(\n   { status: \"A\" },\n   { item: 1, status: 1, \"size.uom\": 1 }\n)\n\n// 也可以只设置不显示某个嵌套字段，下面语句不显示size的uom属性，其余正常显示\ndb.inventory.find(\n   { status: \"A\" },\n   { \"size.uom\": 0 }\n)\n\n// 控制数组中的元素某些字段是否显示\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, \"instock.qty\": 1 } )\n// 结果为：\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d51\"), \"item\" : \"journal\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 5 } ] }\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d52\"), \"item\" : \"notebook\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 5 } ] }\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d55\"), \"item\" : \"postcard\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 15 }, { \"qty\" : 35 } ] }\n\n// 对于instock，只返回数组的最后一个元素\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, instock: { $slice: -1 } } )\n\n// $elemMatch, $slice 和 $ 是唯一能控制数组返回字段的方法，在这里，不可以使用类似于：{ 'instock.0': 1 }这种控制只显示instock数组的第一个元素的。\n```\n\n### 如何显示null或者缺失字段\n```\n// 示例数据\ndb.inventory.insertMany([\n   { _id: 1, item: null },\n   { _id: 2 }\n])\n\n// item设为null时，会返回null，以及不存在该字段的数据，比如第二条数据不存在item字段，也会被返回\ndb.inventory.find( { item: null } )\n// 结果为：\n{ \"_id\" : 1, \"item\" : null }\n{ \"_id\" : 2 }\n\n// 如果想要精确匹配，可以这样：\n// 10 是Null类型的数值表示，具体可看：https://docs.mongodb.com/manual/reference/bson-types/，里面有各种类型对应的数值\ndb.inventory.find( { item : { $type: 10 } } )\n// 结果为：\n{ \"_id\" : 1, \"item\" : null }\n\n// 还可以使用$exists操作符，用于标明字段是否存在\ndb.inventory.find( { item : { $exists: false } } )\n// 结果为：\n{ \"_id\" : 2 }\n// 如果$exists设为true，则返回：\n{ \"_id\" : 1, \"item\" : null }\n```\n\n### 使用游标操作数据\n\n```\n// 可以将find的返回值保存到一个变量中\nvar myCursor = db.users.find( { type: 2 } );\n\nwhile (myCursor.hasNext()) {\n   print(tojson(myCursor.next()));\n}\n\n// 可以使用printjson代替print(tojson()\nvar myCursor = db.users.find( { type: 2 } );\n\nwhile (myCursor.hasNext()) {\n   printjson(myCursor.next());\n}\n\n// 还可以使用游标的forEach方法\nvar myCursor =  db.users.find( { type: 2 } );\n\nmyCursor.forEach(printjson);\n```\n\n游标对象的具体有哪些方法可以看：https://docs.mongodb.com/manual/reference/method/#js-query-cursor-methods\n\n\n## 更新数据\n\n更新数据主要使用：\n* `db.collection.updateOne(<filter>, <update>, <options>)`\n* `db.collection.updateMany(<filter>, <update>, <options>)`\n* `db.collection.replaceOne(<filter>, <update>, <options>)`\n\nmongodb提供了更新操作符去更新数据，比如$set，具体可看文档：https://docs.mongodb.com/manual/reference/operator/update/\n\n有一些操作符，比如$set在字段不存在时会自动添加该字段\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"canvas\", qty: 100, size: { h: 28, w: 35.5, uom: \"cm\" }, status: \"A\" },\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"mat\", qty: 85, size: { h: 27.9, w: 35.5, uom: \"cm\" }, status: \"A\" },\n   { item: \"mousepad\", qty: 25, size: { h: 19, w: 22.85, uom: \"cm\" }, status: \"P\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" },\n   { item: \"sketchbook\", qty: 80, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"sketch pad\", qty: 95, size: { h: 22.85, w: 30.5, uom: \"cm\" }, status: \"A\" }\n] );\n\n// 第一个参数这里也不继续说明了，详细可以看上面查询部分\n\n/*\n** 1. 更新size的uom字段值为cm\n** 2. 更新status字段值为P\n** 3. 更新lastModified为当前时间，如果lastModified字段不存在，会添加该字段\n*/\ndb.inventory.updateOne(\n   { item: \"paper\" },\n   {\n     $set: { \"size.uom\": \"cm\", status: \"P\" },\n     $currentDate: { lastModified: true }\n   }\n)\n// 更新后的数据：\n{ \"_id\" : ObjectId(\"5e6466a4940e1ec922af0d5b\"), \"item\" : \"paper\", \"qty\" : 100, \"size\" : { \"h\" : 8.5, \"w\" : 11, \"uom\" : \"cm\" }, \"status\" : \"P\", \"lastModified\" : ISODate(\"2020-03-08T03:29:48.653Z\") }\n\n// 更新多条数据\ndb.inventory.updateMany(\n   { \"qty\": { $lt: 50 } },\n   {\n     $set: { \"size.uom\": \"in\", status: \"P\" },\n     $currentDate: { lastModified: true }\n   }\n)\n\n/*\n** 替换数据\n** 1. _id字段不能被替换，如果新数据里包含_id字段，则值必须和原数据的一致\n** 2. 新数据不能包含操作符\n*/\ndb.inventory.replaceOne(\n   { item: \"paper\" },\n   { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 40 } ] }\n)\n```\n\n`upsert`属性\n如果`updateOne()`, `updateMany()` 或者 `replaceOne()`包含`upsert: true`参数时，如果这三个方法没有匹配到任何文档，则会创建一个新的插入到集合中，如果匹配到了，则会修改或者替换原文档。\n\n### 使用聚合更新数据\n在聚合中可以使用一下更新操作符：\n* $addFields\n* $set\n* $project\n* $unset\n* $replaceRoot\n* $replaceWith\n\n```\n// 示例数据\ndb.students.insertMany([\n   { _id: 1, test1: 95, test2: 92, test3: 90, modified: new Date(\"01/05/2020\") },\n   { _id: 2, test1: 98, test2: 100, test3: 102, modified: new Date(\"01/05/2020\") },\n   { _id: 3, test1: 95, test2: 110, modified: new Date(\"01/04/2020\") }\n])\n\n/*\n** updateOne方法第二个参数可以是以数组，里面可以有多种操作\n** 1. 新增一个test3字段并设为98\n** 2. 修改modified数据值为当前时间\n*/\ndb.students.updateOne( { _id: 3 }, [ { $set: { \"test3\": 98, modified: \"$$NOW\"} } ] )\n\n\n// 示例数据\ndb.students2.insertMany([\n   { \"_id\" : 1, quiz1: 8, test2: 100, quiz2: 9, modified: new Date(\"01/05/2020\") },\n   { \"_id\" : 2, quiz2: 5, test1: 80, test2: 89, modified: new Date(\"01/05/2020\") },\n])\n\n/*\n** 同时执行多个操作，首先序列化所有文档（集合中的每个文档字段可能并不一致），再更新modified字段\n** 1. 序列化文档，如果文档中没有 quiz1 or quiz2 or test1 or test2 就给它添加该字段，并将值设为0。该操作可以用于将集合中所有文档的字段保持一致\n** 2. 更新文档的modified为当前时间\n*/\ndb.students2.updateMany( {},\n  [\n    { $replaceRoot: { newRoot:\n       { $mergeObjects: [ { quiz1: 0, quiz2: 0, test1: 0, test2: 0 }, \"$$ROOT\" ] }\n    } },\n    { $set: { modified: \"$$NOW\"}  }\n  ]\n)\n// 结果为：\n{ \"_id\" : 1, quiz1: 8, quiz2: 9, test1: 0, test2: 100, modified: new Date(\"01/05/2020\") }\n{ \"_id\" : 2, quiz1: 0, quiz2: 5, test1: 80, test2: 89, modified: new Date(\"01/05/2020\") }\n\n// 示例数据\ndb.students3.insert([\n   { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") },\n   { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") },\n   { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n]);\n\n/*\n** 设置average, grade字段值，并且修改modified值\n** 1.1 设置average字段（如果没有会新增）为tests数组的平均值，0代表保留0个小数，即取证，具体可看$trunc操作符文档https://docs.mongodb.com/manual/reference/operator/aggregation/trunc/\n** 1.2 设置modifed字段为当前时间\n** 1 设置grade字段，根据average的值分别设为A,B,C,D,F\n*/\ndb.students3.updateMany(\n   { },\n   [\n     { $set: { average : { $trunc: [ { $avg: \"$tests\" }, 0 ] }, modified: \"$$NOW\" } },\n     { $set: { grade: { $switch: {\n                           branches: [\n                               { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" },\n                               { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" },\n                               { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" },\n                               { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" }\n                           ],\n                           default: \"F\"\n     } } } }\n   ]\n)\n// 结果为：\n{ \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"average\": 92, \"grade\": \"A\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n{ \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"average\": 90, \"grade\": \"A\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n{ \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"average\": 75, \"grade\": \"C\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n\n// 示例数据\ndb.students4.insertMany([\n  { \"_id\" : 1, \"quizzes\" : [ 4, 6, 7 ] },\n  { \"_id\" : 2, \"quizzes\" : [ 5 ] },\n  { \"_id\" : 3, \"quizzes\" : [ 10, 10, 10 ] }\n])\n\n// 在quizzes后追加[8, 6]\ndb.students4.updateOne( { _id: 2 },\n  [ { $set: { quizzes: { $concatArrays: [ \"$quizzes\", [ 8, 6 ]  ] } } } ]\n)\n// 结果为\n{ \"_id\" : 2, \"quizzes\" : [ 5, 8, 6 ] }\n\n// 示例数据\ndb.temperatures.insertMany([\n  { \"_id\" : 1, \"date\" : ISODate(\"2019-06-23\"), \"tempsC\" : [ 4, 12, 17 ] },\n  { \"_id\" : 2, \"date\" : ISODate(\"2019-07-07\"), \"tempsC\" : [ 14, 24, 11 ] },\n  { \"_id\" : 3, \"date\" : ISODate(\"2019-10-30\"), \"tempsC\" : [ 18, 6, 8 ] }\n])\n\n/*\n** 1. 新增tempsF字段\n** 2. 将tempsC数组里的摄氏度转换为华氏度 f = c * 1.8 + 32\n*/\ndb.temperatures.updateMany( { },\n  [\n    { $addFields: { \"tempsF\": {\n          $map: {\n             input: \"$tempsC\",\n             as: \"celsius\",\n             in: { $add: [ { $multiply: [\"$$celsius\", 9/5 ] }, 32 ] }\n          }\n    } } }\n  ]\n)\n// 结果为：\n{ \"_id\" : 1, \"date\" : ISODate(\"2019-06-23\"), \"tempsC\" : [ 4, 12, 17 ], \"tempsF\": [39.2, 53.6, 62.6] }\n{ \"_id\" : 2, \"date\" : ISODate(\"2019-07-07\"), \"tempsC\" : [ 14, 24, 11 ], \"tempsF\": [57.2, 75.2, 51.8] }\n{ \"_id\" : 3, \"date\" : ISODate(\"2019-10-30\"), \"tempsC\" : [ 18, 6, 8 ], \"tempsF\": [64.4, 42.8, 46.4] }\n```\n\n### update方法\n具体可看文档：https://docs.mongodb.com/manual/reference/update-methods/\n\n* `db.collection.updateOne()`\n* `db.collection.updateMany()`\n* `db.collection.replaceOne()`\n* `db.collection.update()`\n\n* `db.collection.findOneAndReplace()`\n* `db.collection.findOneAndUpdate()`\n* `db.collection.findAndModify()`\n* `db.collection.save()`\n* `db.collection.bulkWrite()`\n\n## 删除数据\n可以使用下面方法删除数据\n\n* `db.collection.deleteMany()`\n* `db.collection.deleteOne()`\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" },\n] );\n\n// 删除inventory所有数据\ndb.inventory.deleteMany({})\n\n// 删除所有匹配的数据\ndb.inventory.deleteMany({ status : \"A\" })\n\n// 删除匹配到的第一条数据\n//db.inventory.deleteOne( { status: \"D\" } )\n```\n\n删除操作不会删除索引，即使删掉所有文档\n","tags":["mongodb"]}]