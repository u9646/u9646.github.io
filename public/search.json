[{"title":"mongodb Query 和 Projection 常用操作符","url":"/mongodb-query-and-projection-operators/","content":"\n> 文档链接 https://docs.mongodb.com/manual/reference/operator/query/\n\n## 比较运算符\n\n### $eq\n`{ <field>: { $eq: <value> } }`\n选择：等于某个值\n\n### $gt\n`{field: {$gt: value} }`\n选择：大于某个值\n\n### $gte\n`{field: {$gte: value} }`\n选择：大于等于某个值\n\n### $in\n`{ field: { $in: [<value1>, <value2>, ... <valueN> ] } }`\n选择：\n1. filed是一个值，并且等于value1 or value2 ...\n1. field是个数组，并且filed中至少存在某个值等于value1 or value2 ...\n\n### $lt\n`{field: {$lt: value} }`\n选择：小于某个值\n\n### $lte\n`{ field: { $lte: value} }`\n选择：小于等于某个值\n\n### $ne\n`{field: {$ne: value} }`\n\n选择：\n1. field不等于某个值\n2. field不存在\n\n### $nin\n`{ field: { $nin: [ <value1>, <value2> ... <valueN> ]} }`\n\n选择：\n1. field值不存在于数组中\n2. field不存在\n\n## 逻辑运算符\n### $and\n`{ $and: [ { <expression1> }, { <expression2> } , ... , { <expressionN> } ] }`\n\n选择同时匹配所有expression的数据\n\n> 如果expression1为false，则mongodb不会继续后续的判断\n\n### $not\n`{ field: { $not: { <operator-expression> } } }`\n\n选择所有不符合operator-expression的数据。\n\n```\n// 选择所有price小于等于1.99或者price字段不存在的数据\ndb.inventory.find( { price: { $not: { $gt: 1.99 } } } )\n```\n\n### $nor\n`{ $nor: [ { <expression1> }, { <expression2> }, ...  { <expressionN> } ] }`\n\n选择同时不满足所有expression的数据\n\n### $or\n`{ $or: [ { <expression1> }, { <expression2> }, ... , { <expressionN> } ] }`\n\n选择至少满足一个expression的数据\n\n## 元素运算符\n### $exists\n`{ field: { $exists: <boolean> } }`\n\n选择filed是否存在的数据，$exists: true代表存在，false代表不存在\n\n### $type\n`{ field: { $type: <BSON type> } }`\n选择filed是某个具体类型的实例的数据，可以写具体type或者对应数字\n\n具体BSON type可以看文档：https://docs.mongodb.com/manual/reference/operator/query/type/#document-type-available-types\n\n## 数组运算符\n### $all\n`{ <field>: { $all: [ <value1> , <value2> ... ] } }`\n\n选择filed是个数组，并且包含所有value1 and value2 ...\n\n### $elemMatch\n`{ <field>: { $elemMatch: { <query1>, <query2>, ... } } }`\n\n选择filed是个数组并且至少有一个元素满足query1 or query2 ...\n\n> 如果query只有一个，那么你不需要使用$elemMatch\n\n### $size\n`db.collection.find( { field: { $size: 2 } } );`\n\n选择filed数组长度等于某个值的数据\n\n## projection运算符\n\n### $\n```\n// 示例数据\n{ \"_id\" : 1, \"semester\" : 1, \"grades\" : [ 70, 87, 90 ] }\n{ \"_id\" : 2, \"semester\" : 1, \"grades\" : [ 90, 88, 92 ] }\n{ \"_id\" : 3, \"semester\" : 1, \"grades\" : [ 85, 100, 90 ] }\n{ \"_id\" : 4, \"semester\" : 2, \"grades\" : [ 79, 85, 80 ] }\n{ \"_id\" : 5, \"semester\" : 2, \"grades\" : [ 88, 88, 92 ] }\n{ \"_id\" : 6, \"semester\" : 2, \"grades\" : [ 95, 90, 96 ] }\n\n// 只返回grades数组的第一个元素\ndb.students.find( { semester: 1, grades: { $gte: 85 } },\n                  { \"grades.$\": 1 } )\n// 结果为：\n{ \"_id\" : 1, \"grades\" : [ 87 ] }\n{ \"_id\" : 2, \"grades\" : [ 90 ] }\n{ \"_id\" : 3, \"grades\" : [ 85 ] }\n\n// { \"grades.$\": 1 } 这里的1只是代表显示grades字段\n```\n\n### $elemMatch\n用于控制数据返回值，只会显示某个字段第一个满足$elemMatch的元素\n\n```\n// 示例数据\n{\n _id: 1,\n zipcode: \"63109\",\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: \"63110\",\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: \"63109\",\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: \"63109\",\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n              { name: \"ruth\", school: 102, age: 16 },\n           ]\n}\n\ndb.schools.find( { zipcode: \"63109\" },\n                 { students: { $elemMatch: { school: 102 } } } )\n// 结果为：\n{ \"_id\" : 1, \"students\" : [ { \"name\" : \"john\", \"school\" : 102, \"age\" : 10 } ] }\n{ \"_id\" : 3 }\n{ \"_id\" : 4, \"students\" : [ { \"name\" : \"barney\", \"school\" : 102, \"age\" : 7 } ] }\n\n\n\ndb.schools.find( { zipcode: \"63109\" },\n                 { students: { $elemMatch: { school: 102, age: { $gt: 10} } } } )\n// 结果为：\n{ \"_id\" : 1, \"students\" : [ { \"name\" : \"jess\", \"school\" : 102, \"age\" : 11 } ] }\n{ \"_id\" : 3 }\n{ \"_id\" : 4, \"students\" : [ { \"name\" : \"ruth\", \"school\" : 102, \"age\" : 16 } ] }\n```\n\n### $slice\n`db.collection.find( { field: value }, { array: {$slice: count } } )`\n\n用于控制某个数组字段返回多少个元素\n\n```\n// 返回comments前5个元素\ndb.posts.find( {}, { comments: { $slice: 5 } } )\n\n// 返回最后5个元素\n//db.posts.find( {}, { comments: { $slice: -5 } } )\n```\n\n$slice还可以是个数组，即[skip, limit]，表明跳到第skip个元素，从这里选择limit个。\n\n```\n// 跳过前20个元素，然后开始往后选择10个\ndb.posts.find( {}, { comments: { $slice: [ 20, 10 ] } } )\n\n// 从倒数第20个元素开始，往后选择10个元素\ndb.posts.find( {}, { comments: { $slice: [ -20, 10 ] } } )\n```\n\n还有一些其他操作符，可以参考文档。\n","tags":["mongodb"]},{"title":"技术精选 - 第1期","url":"/hotlink-1/","content":"\n[网站性能指标这么多，你到底选对了吗](https://mp.weixin.qq.com/s/ITb0IWzLPj715NUgL7C4HA)\n从用户体验角度来看一个网址或者app是否有吸引力，75%的人是认为页面加载时长是一个核心因素，远远高于其他影响用户体验的问题，例如：简洁易用、屏幕适配、设计吸引力等等。\n\n[npm install 原理分析](https://mp.weixin.qq.com/s/byX6V6fL9O1SuEdppZO2CA)\n开门见山，npm install 大概会经过上面的几个流程，本篇文章来讲一讲各个流程的实现细节、发展以及为何要这样实现。\n\n[Webpack 插件开发如此简单！](https://mp.weixin.qq.com/s/nimOuftziXCWHV61FfjWog)\n本文将带你一起开发第一个 Webpack 插件，从 Webpack 配置工程师，迈向 Webpack 开发工程师！\n\n[让你牛B加身的前端必会Linux命令](https://mp.weixin.qq.com/s/80UEbeEfPBV2LMmRqJFT7w)\n本文主要针对于 FEer 们。作为前端，一开始我们总是和 HTML/JavaScript/CSS 三大块打交道，但是久而久之，我们就会接触更多的内容，比如服务的部署。而这一块对于我们的要求会更全面，其中对 Linux 指令就有很多要求。如果你想要部署服务，而又没有成熟的工具或平台可以借助，需要完全自己来操作的话，你就需要准备好部署服务需要的所有文件、登录指定的服务器、发布指定文件、启动服务、服务器启动不成功时候进行调试以及服务维护过程中进行问题的排查。本文就将从这一条线讲起，分享歪马在工作中所积累的一些实用指令。\n\n[给你梳理了 44 个 CSS 精选知识点](https://mp.weixin.qq.com/s/Pw3VgFpijTYRkJyYPvlJgA)\n一个周五的晚上，闲来无事整理下自己的 github（经常做收藏党），今天打算都过一遍，发现一个 star很高的项目，里面有大量的 CSS 片段，而且标题很诱人，然后又花了将近1个小时从头到尾过了一遍，其中一些是我们常用的一些知识点，另外也包含一些比较新的属性的应用，知识点挺多的，为了让大家看起来更方便些，然后又花了点（很长很长）时间翻译成中文。\n\n[你必须懂的前端性能优化](https://mp.weixin.qq.com/s/DdbaiuZd4RbqUod0jhn_vg)\n从输入 URL 到页面加载完成的过程：\n\n首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来\n 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n\n[深入理解 JavaScript 原型](https://mp.weixin.qq.com/s/qg9LNm3awHBao1Du5n6KMQ)\nPrototype 是 JavaScript 里的一个基础概念，原本应该很容易理解。然而，出于各种原因，大部分前端开发者（包括我），在刚开始学习 JS 时，原型和原型链都是一个需要克服的困难。\n\n[Promise 链式调用顺序引发的思考](https://mp.weixin.qq.com/s/zTVRIwmA_9oQ-Ea_b1oqqA)\n近一个多月没有写博客了，前阵子一个朋友问我一个关于 Promise 链式调用执行顺序的问题\n","tags":["hotlink"]},{"title":"mongodb 增删改查CURD基本操作总结","url":"/mongodb-curd-api/","content":"\n> 基于mongodb v4.2 https://docs.mongodb.com/manual/introduction/\n\n## 插入数据\n\n### 插入一条数据\n`db.collection.insertOne()` 插入一个文档到集合中\n\n```\ntry {\n   db.products.insertOne( { item: \"card\", qty: 15 } );\n} catch (e) {\n   print (e);\n};\n// 返回值：\n{\n   \"acknowledged\" : true,\n   \"insertedId\" : ObjectId(\"56fc40f9d735c28df206d078\")\n}\n```\n\n### 插入多条数据\n`db.collection.insertMany()` 同时插入多条数据到集合中\n\n```\ntry {\n   db.products.insertMany( [\n      { item: \"card\", qty: 15 },\n      { item: \"envelope\", qty: 20 },\n      { item: \"stamps\" , qty: 30 }\n   ] );\n} catch (e) {\n   print (e);\n}\n// 返回值：\n{\n   \"acknowledged\" : true,\n   \"insertedIds\" : [\n      ObjectId(\"562a94d381cb9f1cd6eb0e1a\"),\n      ObjectId(\"562a94d381cb9f1cd6eb0e1b\"),\n      ObjectId(\"562a94d381cb9f1cd6eb0e1c\")\n   ]\n}\n```\n\ninsert 特性：\n如果当前集合不存在，会自动创建一个集合。\n\n_id 属性：\nmongodb里面，如果你不提供_id，mongodb会默认在插入文档的时候为每一个文档创建一个唯一的_id，作为主键\n\n\n## 查找数据\nmongodb可以使用`find`方法查找数据\n\n### 普通查询\n\n> 每个文档插入到集合中如果不提供一个_id字段，则mongodb会自动生成一个，并且在查询语句中默认返回，这里省略没有显示该字段\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"A\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" }\n]);\n```\n\n```\n// 查找 size 等于 { h: 14, w: 21, uom: \"cm\" } 的数据\ndb.inventory.find( { size: { h: 14, w: 21, uom: \"cm\" } } )\n// or 查找 qty 等于 25 的数据\ndb.inventory.find({ qty: 25 })\n// or 使用嵌套查询 size 的 uom 等于 in 的数据\ndb.inventory.find( { \"size.uom\": \"in\" } )\n// $lt 小于\ndb.inventory.find( { \"size.h\": { $lt: 15 } } )\n// 复合条件查询，查询 size.h 小于 15， 并且 size.uom 等于 in，并且 status 等于 D 的数据\ndb.inventory.find( { \"size.h\": { $lt: 15 }, \"size.uom\": \"in\", status: \"D\" } )\n```\n\n### 查询数组\n```\n// 示例数据\ndb.inventory.insertMany([\n   { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"], dim_cm: [ 14, 21 ] },\n   { item: \"notebook\", qty: 50, tags: [\"red\", \"blank\"], dim_cm: [ 14, 21 ] },\n   { item: \"paper\", qty: 100, tags: [\"red\", \"blank\", \"plain\"], dim_cm: [ 14, 21 ] },\n   { item: \"planner\", qty: 75, tags: [\"blank\", \"red\"], dim_cm: [ 22.85, 30 ] },\n   { item: \"postcard\", qty: 45, tags: [\"blue\"], dim_cm: [ 10, 15.25 ] }\n]);\n```\n\n```\n// 查询 tags 等于 [\"red\", \"blank\"] 的数据\ndb.inventory.find( { tags: [\"red\", \"blank\"] } )\n\n// 或者你想查询tags包含 red blank，不管它的顺序，或者是否还有其他元素，你可以使用 `$all`\ndb.inventory.find( { tags: { $all: [\"red\", \"blank\"] } } )\n\n// 查询tags 里面包含 red的数据\ndb.inventory.find( { tags: \"red\" } )\n\n// 查询dim_cm里面最少有一个值大于 25\ndb.inventory.find( { dim_cm: { $gt: 25 } } )\n\n/*\n** 查询dim_cm里面:\n** 1. 有一个元素同时满足大于15并且小于20\n** 2. 有两个分别满足小于15以及大于20\n*/\ndb.inventory.find( { dim_cm: { $gt: 15, $lt: 20 } } )\n// 所以结果是返回这四条：\n{ \"item\" : \"journal\", \"qty\" : 25, \"tags\" : [ \"blank\", \"red\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"notebook\", \"qty\" : 50, \"tags\" : [ \"red\", \"blank\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"paper\", \"qty\" : 100, \"tags\" : [ \"red\", \"blank\", \"plain\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"postcard\", \"qty\" : 45, \"tags\" : [ \"blue\" ], \"dim_cm\" : [ 10, 15.25 ] }\n\n// 查询dim_cm里面至少有一个元素同时满足大于22并且小于30的数据\ndb.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } )\n\n// 查询dim_cm第二个元素大于25的数据\ndb.inventory.find( { \"dim_cm.1\": { $gt: 25 } } )\n\n// 查询dim_cm的tags数组长度为3的数据\ndb.inventory.find( { \"tags\": { $size: 3 } } )\n```\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", instock: [ { warehouse: \"A\", qty: 5 }, { warehouse: \"C\", qty: 15 } ] },\n   { item: \"notebook\", instock: [ { warehouse: \"C\", qty: 5 } ] },\n   { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 15 } ] },\n   { item: \"planner\", instock: [ { warehouse: \"A\", qty: 40 }, { warehouse: \"B\", qty: 5 } ] },\n   { item: \"postcard\", instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] }\n]);\n\n// 查询instock数组里面有一个元素为{ warehouse: \"A\", qty: 5 }的数据，必须warehouse等于A并且qty等于5，包括顺序也必须一致\ndb.inventory.find( { \"instock\": { warehouse: \"A\", qty: 5 } } )\n\n// 查询instock数组里面至少有一个元素的qty字段值小于等于20的数组\ndb.inventory.find( { 'instock.qty': { $lte: 20 } } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"notebook\", \"instock\" : [ { \"warehouse\" : \"C\", \"qty\" : 5 } ] }\n{ \"item\" : \"paper\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 60 }, { \"warehouse\" : \"B\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n{ \"item\" : \"postcard\", \"instock\" : [ { \"warehouse\" : \"B\", \"qty\" : 15 }, { \"warehouse\" : \"C\", \"qty\" : 35 } ] }\n\n// 查询instock数组的第一个元素的qty字段小于等于20的数据\ndb.inventory.find( { 'instock.0.qty': { $lte: 20 } } )\n\n// 查询instock数组里至少有一个元素同时满足qty等于5并且warehouse等于A的数组\ndb.inventory.find( { \"instock\": { $elemMatch: { qty: 5, warehouse: \"A\" } } } )\n\n// 查询instock数组里至少有一个元素的qty同时满足大于10并且小于等于20\ndb.inventory.find( { \"instock\": { $elemMatch: { qty: { $gt: 10, $lte: 20 } } } } )\n\n// 查询instock数组里至少有一个元素满足大于10或者小于等于20\ndb.inventory.find( { \"instock.qty\": { $gt: 10,  $lte: 20 } } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"paper\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 60 }, { \"warehouse\" : \"B\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n{ \"item\" : \"postcard\", \"instock\" : [ { \"warehouse\" : \"B\", \"qty\" : 15 }, { \"warehouse\" : \"C\", \"qty\" : 35 } ] }\n\n// 查询instock里任意一个元素的qty等于5并且任意一个元素的warehouse等于A的数据\ndb.inventory.find( { \"instock.qty\": 5, \"instock.warehouse\": \"A\" } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n```\n\n### 控制查询语句输出结果\n默认情况下，查询语句会返回文档的所有字段，我们可以通过第二个参数来自定义返回文档里的哪些字段\n\n关于第一个参数，我们这里就不详细说明了，可参考上面\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n  { item: \"journal\", status: \"A\", size: { h: 14, w: 21, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 5 } ] },\n  { item: \"notebook\", status: \"A\",  size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"C\", qty: 5 } ] },\n  { item: \"paper\", status: \"D\", size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"A\", qty: 60 } ] },\n  { item: \"planner\", status: \"D\", size: { h: 22.85, w: 30, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 40 } ] },\n  { item: \"postcard\", status: \"A\", size: { h: 10, w: 15.25, uom: \"cm\" }, instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] }\n]);\n\n// 返回所有文档的status为的A的数据的所有字段\ndb.inventory.find( { status: \"A\" } )\n\n// 只返回文档的item, status字段以及_id（默认显示），1代表显示，0则是不显示\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1 } )\n\n// 如果想要_id也不返回，可以这样：\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, _id: 0 } )\n\n// 也可以单独给某些不想显示的字段设为0，其余的正常显示\ndb.inventory.find( { status: \"A\" }, { status: 0, instock: 0 } )\n\n// 还可以控制嵌套对象的字段，下面语句只显示_id, item, status, 以及size的uom字段\ndb.inventory.find(\n   { status: \"A\" },\n   { item: 1, status: 1, \"size.uom\": 1 }\n)\n\n// 也可以只设置不显示某个嵌套字段，下面语句不显示size的uom属性，其余正常显示\ndb.inventory.find(\n   { status: \"A\" },\n   { \"size.uom\": 0 }\n)\n\n// 控制数组中的元素某些字段是否显示\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, \"instock.qty\": 1 } )\n// 结果为：\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d51\"), \"item\" : \"journal\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 5 } ] }\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d52\"), \"item\" : \"notebook\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 5 } ] }\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d55\"), \"item\" : \"postcard\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 15 }, { \"qty\" : 35 } ] }\n\n// 对于instock，只返回数组的最后一个元素\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, instock: { $slice: -1 } } )\n\n// $elemMatch, $slice 和 $ 是唯一能控制数组返回字段的方法，在这里，不可以使用类似于：{ 'instock.0': 1 }这种控制只显示instock数组的第一个元素的。\n```\n\n### 如何显示null或者缺失字段\n```\n// 示例数据\ndb.inventory.insertMany([\n   { _id: 1, item: null },\n   { _id: 2 }\n])\n\n// item设为null时，会返回null，以及不存在该字段的数据，比如第二条数据不存在item字段，也会被返回\ndb.inventory.find( { item: null } )\n// 结果为：\n{ \"_id\" : 1, \"item\" : null }\n{ \"_id\" : 2 }\n\n// 如果想要精确匹配，可以这样：\n// 10 是Null类型的数值表示，具体可看：https://docs.mongodb.com/manual/reference/bson-types/，里面有各种类型对应的数值\ndb.inventory.find( { item : { $type: 10 } } )\n// 结果为：\n{ \"_id\" : 1, \"item\" : null }\n\n// 还可以使用$exists操作符，用于标明字段是否存在\ndb.inventory.find( { item : { $exists: false } } )\n// 结果为：\n{ \"_id\" : 2 }\n// 如果$exists设为true，则返回：\n{ \"_id\" : 1, \"item\" : null }\n```\n\n### 使用游标操作数据\n\n```\n// 可以将find的返回值保存到一个变量中\nvar myCursor = db.users.find( { type: 2 } );\n\nwhile (myCursor.hasNext()) {\n   print(tojson(myCursor.next()));\n}\n\n// 可以使用printjson代替print(tojson()\nvar myCursor = db.users.find( { type: 2 } );\n\nwhile (myCursor.hasNext()) {\n   printjson(myCursor.next());\n}\n\n// 还可以使用游标的forEach方法\nvar myCursor =  db.users.find( { type: 2 } );\n\nmyCursor.forEach(printjson);\n```\n\n游标对象的具体有哪些方法可以看：https://docs.mongodb.com/manual/reference/method/#js-query-cursor-methods\n\n\n## 更新数据\n\n更新数据主要使用：\n* `db.collection.updateOne(<filter>, <update>, <options>)`\n* `db.collection.updateMany(<filter>, <update>, <options>)`\n* `db.collection.replaceOne(<filter>, <update>, <options>)`\n\nmongodb提供了更新操作符去更新数据，比如$set，具体可看文档：https://docs.mongodb.com/manual/reference/operator/update/\n\n有一些操作符，比如$set在字段不存在时会自动添加该字段\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"canvas\", qty: 100, size: { h: 28, w: 35.5, uom: \"cm\" }, status: \"A\" },\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"mat\", qty: 85, size: { h: 27.9, w: 35.5, uom: \"cm\" }, status: \"A\" },\n   { item: \"mousepad\", qty: 25, size: { h: 19, w: 22.85, uom: \"cm\" }, status: \"P\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" },\n   { item: \"sketchbook\", qty: 80, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"sketch pad\", qty: 95, size: { h: 22.85, w: 30.5, uom: \"cm\" }, status: \"A\" }\n] );\n\n// 第一个参数这里也不继续说明了，详细可以看上面查询部分\n\n/*\n** 1. 更新size的uom字段值为cm\n** 2. 更新status字段值为P\n** 3. 更新lastModified为当前时间，如果lastModified字段不存在，会添加该字段\n*/\ndb.inventory.updateOne(\n   { item: \"paper\" },\n   {\n     $set: { \"size.uom\": \"cm\", status: \"P\" },\n     $currentDate: { lastModified: true }\n   }\n)\n// 更新后的数据：\n{ \"_id\" : ObjectId(\"5e6466a4940e1ec922af0d5b\"), \"item\" : \"paper\", \"qty\" : 100, \"size\" : { \"h\" : 8.5, \"w\" : 11, \"uom\" : \"cm\" }, \"status\" : \"P\", \"lastModified\" : ISODate(\"2020-03-08T03:29:48.653Z\") }\n\n// 更新多条数据\ndb.inventory.updateMany(\n   { \"qty\": { $lt: 50 } },\n   {\n     $set: { \"size.uom\": \"in\", status: \"P\" },\n     $currentDate: { lastModified: true }\n   }\n)\n\n/*\n** 替换数据\n** 1. _id字段不能被替换，如果新数据里包含_id字段，则值必须和原数据的一致\n** 2. 新数据不能包含操作符\n*/\ndb.inventory.replaceOne(\n   { item: \"paper\" },\n   { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 40 } ] }\n)\n```\n\n`upsert`属性\n如果`updateOne()`, `updateMany()` 或者 `replaceOne()`包含`upsert: true`参数时，如果这三个方法没有匹配到任何文档，则会创建一个新的插入到集合中，如果匹配到了，则会修改或者替换原文档。\n\n### 使用聚合更新数据\n在聚合中可以使用一下更新操作符：\n* $addFields\n* $set\n* $project\n* $unset\n* $replaceRoot\n* $replaceWith\n\n```\n// 示例数据\ndb.students.insertMany([\n   { _id: 1, test1: 95, test2: 92, test3: 90, modified: new Date(\"01/05/2020\") },\n   { _id: 2, test1: 98, test2: 100, test3: 102, modified: new Date(\"01/05/2020\") },\n   { _id: 3, test1: 95, test2: 110, modified: new Date(\"01/04/2020\") }\n])\n\n/*\n** updateOne方法第二个参数可以是以数组，里面可以有多种操作\n** 1. 新增一个test3字段并设为98\n** 2. 修改modified数据值为当前时间\n*/\ndb.students.updateOne( { _id: 3 }, [ { $set: { \"test3\": 98, modified: \"$$NOW\"} } ] )\n\n\n// 示例数据\ndb.students2.insertMany([\n   { \"_id\" : 1, quiz1: 8, test2: 100, quiz2: 9, modified: new Date(\"01/05/2020\") },\n   { \"_id\" : 2, quiz2: 5, test1: 80, test2: 89, modified: new Date(\"01/05/2020\") },\n])\n\n/*\n** 同时执行多个操作，首先序列化所有文档（集合中的每个文档字段可能并不一致），再更新modified字段\n** 1. 序列化文档，如果文档中没有 quiz1 or quiz2 or test1 or test2 就给它添加该字段，并将值设为0。该操作可以用于将集合中所有文档的字段保持一致\n** 2. 更新文档的modified为当前时间\n*/\ndb.students2.updateMany( {},\n  [\n    { $replaceRoot: { newRoot:\n       { $mergeObjects: [ { quiz1: 0, quiz2: 0, test1: 0, test2: 0 }, \"$$ROOT\" ] }\n    } },\n    { $set: { modified: \"$$NOW\"}  }\n  ]\n)\n// 结果为：\n{ \"_id\" : 1, quiz1: 8, quiz2: 9, test1: 0, test2: 100, modified: new Date(\"01/05/2020\") }\n{ \"_id\" : 2, quiz1: 0, quiz2: 5, test1: 80, test2: 89, modified: new Date(\"01/05/2020\") }\n\n// 示例数据\ndb.students3.insert([\n   { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") },\n   { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") },\n   { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n]);\n\n/*\n** 设置average, grade字段值，并且修改modified值\n** 1.1 设置average字段（如果没有会新增）为tests数组的平均值，0代表保留0个小数，即取证，具体可看$trunc操作符文档https://docs.mongodb.com/manual/reference/operator/aggregation/trunc/\n** 1.2 设置modifed字段为当前时间\n** 1 设置grade字段，根据average的值分别设为A,B,C,D,F\n*/\ndb.students3.updateMany(\n   { },\n   [\n     { $set: { average : { $trunc: [ { $avg: \"$tests\" }, 0 ] }, modified: \"$$NOW\" } },\n     { $set: { grade: { $switch: {\n                           branches: [\n                               { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" },\n                               { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" },\n                               { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" },\n                               { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" }\n                           ],\n                           default: \"F\"\n     } } } }\n   ]\n)\n// 结果为：\n{ \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"average\": 92, \"grade\": \"A\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n{ \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"average\": 90, \"grade\": \"A\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n{ \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"average\": 75, \"grade\": \"C\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n\n// 示例数据\ndb.students4.insertMany([\n  { \"_id\" : 1, \"quizzes\" : [ 4, 6, 7 ] },\n  { \"_id\" : 2, \"quizzes\" : [ 5 ] },\n  { \"_id\" : 3, \"quizzes\" : [ 10, 10, 10 ] }\n])\n\n// 在quizzes后追加[8, 6]\ndb.students4.updateOne( { _id: 2 },\n  [ { $set: { quizzes: { $concatArrays: [ \"$quizzes\", [ 8, 6 ]  ] } } } ]\n)\n// 结果为\n{ \"_id\" : 2, \"quizzes\" : [ 5, 8, 6 ] }\n\n// 示例数据\ndb.temperatures.insertMany([\n  { \"_id\" : 1, \"date\" : ISODate(\"2019-06-23\"), \"tempsC\" : [ 4, 12, 17 ] },\n  { \"_id\" : 2, \"date\" : ISODate(\"2019-07-07\"), \"tempsC\" : [ 14, 24, 11 ] },\n  { \"_id\" : 3, \"date\" : ISODate(\"2019-10-30\"), \"tempsC\" : [ 18, 6, 8 ] }\n])\n\n/*\n** 1. 新增tempsF字段\n** 2. 将tempsC数组里的摄氏度转换为华氏度 f = c * 1.8 + 32\n*/\ndb.temperatures.updateMany( { },\n  [\n    { $addFields: { \"tempsF\": {\n          $map: {\n             input: \"$tempsC\",\n             as: \"celsius\",\n             in: { $add: [ { $multiply: [\"$$celsius\", 9/5 ] }, 32 ] }\n          }\n    } } }\n  ]\n)\n// 结果为：\n{ \"_id\" : 1, \"date\" : ISODate(\"2019-06-23\"), \"tempsC\" : [ 4, 12, 17 ], \"tempsF\": [39.2, 53.6, 62.6] }\n{ \"_id\" : 2, \"date\" : ISODate(\"2019-07-07\"), \"tempsC\" : [ 14, 24, 11 ], \"tempsF\": [57.2, 75.2, 51.8] }\n{ \"_id\" : 3, \"date\" : ISODate(\"2019-10-30\"), \"tempsC\" : [ 18, 6, 8 ], \"tempsF\": [64.4, 42.8, 46.4] }\n```\n\n### update方法\n具体可看文档：https://docs.mongodb.com/manual/reference/update-methods/\n\n* `db.collection.updateOne()`\n* `db.collection.updateMany()`\n* `db.collection.replaceOne()`\n* `db.collection.update()`\n\n* `db.collection.findOneAndReplace()`\n* `db.collection.findOneAndUpdate()`\n* `db.collection.findAndModify()`\n* `db.collection.save()`\n* `db.collection.bulkWrite()`\n\n## 删除数据\n可以使用下面方法删除数据\n\n* `db.collection.deleteMany()`\n* `db.collection.deleteOne()`\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" },\n] );\n\n// 删除inventory所有数据\ndb.inventory.deleteMany({})\n\n// 删除所有匹配的数据\ndb.inventory.deleteMany({ status : \"A\" })\n\n// 删除匹配到的第一条数据\n//db.inventory.deleteOne( { status: \"D\" } )\n```\n\n删除操作不会删除索引，即使删掉所有文档\n","tags":["mongodb"]}]