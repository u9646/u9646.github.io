[{"title":"JavaScript 原型、原型链概念理解","url":"/js-prototype/","content":"\n![](https://github.com/u9646/assets/blob/master/public/WeChatee3b7f703390054a53e5e450712f665f.png?raw=true)\n\n## 原型\n让我们从一张图开始。\n\n首先，我们看`Person`这个构造函数。它就是一个普通的函数：\n```\nfunction Person () {}\n```\n\n然后通过`new`操作符，我们可以生成一个实例：\n```\nvar person = new Person()\n```\n\n在我们定义了`Person`这个构造函数的时候，其实还生成了一个对象，这个对象就是原型对象。也就是图中的`Person.prototype`。它就是一个普通的对象。如果我们在控制台打印出来是这样的：\n```\n{\n  constructor: ƒ Person()\n  __proto__: Object\n}\n```\n\n它有一个`constructor`执行其构造函数。构造函数可以通过prototype属性访问原型。\n\n当我们使用`new`操作符创建了一个实例`person`的时候，通过还将这个实例同其构造函数的原型通过`__proto__`关联起来了。\n\n这就是构造函数、原型、实例三者的关系。也就是原型的概念。\n\n## 原型链\n\n从上面我们大概了解了原型的概念。那么什么是原型链呢？\n\n我们看`Person.prototype`。上面我们讲到，原型对象其实就是一个普通的对象，它有一个`constructor`属性指向其构造函数。它还有一个属性`__proto__`指向的是这个对象的原型。\n\n我们知道对象可以通过`Object`构造函数生成。就如同通过`Person`new一个`person`的实例，这个实例有一个属性`__proto__`指向`Person.prototype`一样。\n\n原型对象也是通过构造函数生成的。即`Object`。所以它也有一个`__proto__`属性指向其构造函数的原型，也就是`Object.prototype`。\n\n然后`Object.prototype`其实也是一个普通对象，只是它相比`Person.prototype`。它上面还有一些其他属性，我们打印一下看看：\n```\n{\n  constructor: ƒ Object()\n  __defineGetter__: ƒ __defineGetter__()\n  __defineSetter__: ƒ __defineSetter__()\n  hasOwnProperty: ƒ hasOwnProperty()\n  __lookupGetter__: ƒ __lookupGetter__()\n  __lookupSetter__: ƒ __lookupSetter__()\n  isPrototypeOf: ƒ isPrototypeOf()\n  propertyIsEnumerable: ƒ propertyIsEnumerable()\n  toString: ƒ toString()\n  valueOf: ƒ valueOf()\n  toLocaleString: ƒ toLocaleString()\n  get __proto__: ƒ __proto__()\n  set __proto__: ƒ __proto__()\n}\n```\n\n我们可以看到，它这里定义了`__proto__`属性的`getter/setter`。\n\n那么`Object.prototype.__proto__`是什么呢？通过控制台我们可以看到返回的是：`null`。\n\n到这里，我们其实以及可以看到，我们通过`Person`构造出来的`person`实例对象，通过`__proto__`属性，其实和`Object`关联了起来。\n\n而这样一个链条我们就称之为原型链。就是图中蓝色的线。\n\n那么原型链的作用是什么呢？\n\n我们还是通过上面的`person`实例来说明。如果我们在控制台尝试`person.toString()`。我们会发现会返回`[object Object]`。这里姑且先不说为什么返回这个，我们其实并没有定义`toString`方法，那么为什么可以调用呢？\n\n其实这里就是利用原型链的机制。当js在执行这句代码的时候，它会尝试在`person`上看有没有`toString`方法，如果没找到会去`Person.prototype`上查找。如果还是没找到，会去`Object.prototype`上查找，上面我们也打印出来，这上面是有`toString`方法的。所以`person.toString()`执行成功了，而不是报错，提示没有`toString`方法。\n\n通过原型链我们可以实现其他面向对象语言的继承的概念。\n\n## Function的原型是什么？\n通过控制台，我们可以看到：\n```\nfunction anonymous() {}\narguments: (...)\ncaller: (...)\nlength: 0\nname: \"\"\nconstructor: ƒ Function()\napply: ƒ apply()\nbind: ƒ bind()\ncall: ƒ call()\ntoString: ƒ toString()\nSymbol(Symbol.hasInstance): ƒ [Symbol.hasInstance]()\nget arguments: ƒ ()\nset arguments: ƒ ()\nget caller: ƒ ()\nset caller: ƒ ()\n__proto__: Object\n[[FunctionLocation]]: <unknown>\n[[Scopes]]: Scopes[0]\n```\n\n它其实是一个`anonymous`函数。并不是对一个普通对象。但是它同样有一个`__proto__`属性，指向了其原型，也就是`Object.prototype`。\n\n所有构造函数（除了通过bind,call返回的函数，以及箭头函数）都有一个`__proto__`属性指向`Function.prototype`。\n\n看开始的图，也就是`Person.__proto === Function.prototype`。`Object.__proto === Function.prototype`；\n\n包括其他的内置构造函数，比如`Number`, `String`等。\n\n所以也就有了`Function.__proto__ === Function.prototype`为`true`。这样的情况。我理解是这些其实是js语言内置的原型对象。和`Object.prototype`一样。首先是有了函数的原型，即`Function.prototype`。然后为了`Function`构造函数能够直接访问原型上的方法，所以将其`__proto__`属性指向了函数的原型。\n\n如果你执行`console.log(Number.prototype)`, `console.log(Date.prototype)`。你会发现都有一些区别，Number原型有一些特有函数的实现，Date也是如此。\n\n这些都是js内部实现的一些基础原型对象。\n","tags":["JavaScript"]},{"title":"CSP frame-ancestors 对比 X-Frame-Options","url":"/csp-frame-ancestors-vs-x-frame-options/","content":"\n> 这两个字段都是用于控制别的网站使用iframe或者frame加载你的网站的行为\n\n### X-Frame-Options\n该字段有三个可能的值，分别为`deny`,  `sameorigin`, `allow-from https://example.com/`；\n\n#### deny\n`deny`表示禁止任何使用iframe或者frame加载你的网站。\n\n#### sameorigin\n`sameorigin`表示只允许同源的网站使用iframe或者frame加载你的网站\n\n#### allow-from\n`allow-from`表示只允许该网站使用iframe或者frame加载你的网站。\n\n注意：强烈建议不要使用该属性，有两个问题：\n\n1. 浏览器兼容性很差，具体可参考 [MDN X-Frame-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options)\n2. 只能填写一个白名单地址\n\n以chrome v80 为例：\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/allow-from-test.png?raw=true)\n虽然allow-from写成了3100端口，但是页面依然加载出来了。经过测试，safari, firefox（和下面版本相同）都可以正常加载，说明它们都不支持该属性。\n\n#### 如何使用？\n\n> ***设置 meta 标签是无效的！例如 `<meta http-equiv=\"X-Frame-Options\" content=\"deny\">` 没有任何效果。不要这样用！只有当像下面示例那样设置 HTTP 头 X-Frame-Options 才会生效。***\n\n在请求头中增加`X-Frame-Options`例如：`X-Frame-Options: sameorigin`\n\n### CSP frame-ancestors\nCSP是指[Content-Security-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)。\n\n`frame-ancestors`是其中一个指令。指定了一个可以包含`<frame>`，`<iframe>`，`<object>`，`<embed>`，or `<applet>`等元素的有效父级。\n\n> ***该指令不支持通过<meta> 元素或通过 `Content-Security-policy-Report-Only` 头域所指定.***\n\n当`frame-ancestors`设为`none`时，作用类似于`X-Frame-Options: deny`。\n\n`frame-ancestors`策略可以设置一个或多个源`<source>`：\n\n#### `<host-source>`\n主机的名称或IP地址，以及一个可选的URL scheme和／或端口号\n\n例如：\n* http://*.example.com: 匹配所有使用http:URL scheme并来对于example.com及其子域名的加载意图。\n* mail.example.com:443: 匹配所有对于mail.example.com在443端口的访问意图。\n* https://store.example.com: 匹配所有使用https:访问store.example.com的意图。\n\n#### `<scheme-source>`\n一个schema配置，比如'http:'或'https:'。注意，冒号是必要的。你同样也可以指定一个data schema（但并不推荐）。\n\n例如：\n* 'data:' 允许 data: URIs 作为内容源。 这是不安全的，攻击者可以用此来注入恶意代码。请谨慎使用，并不要令其作用于脚本。\n* 'mediastream:' 允许 mediastream: URIs 作为内容源.\n* 'blob:' 允许 blob: URIs 作为内容源.\n* 'filesystem:' 允许 filesystem: URIs 作为内容源.\n\n#### self\n指向一个该受保护文档所在的源，包含同样的URL schema和端口号。必须用单引号设置。有些浏览器会从源指令中排除blob和filesystem。需要允许这些内容类型的站点可以通过Data属性指定它们。\n\n例如：`Content-Security-Policy: frame-ancestors 'self'`\n\n#### none\n指向一个空集，意味着没有URL会被匹配。也需要单引号包裹设置。\n例如：`Content-Security-Policy: frame-ancestors 'none'`\n\n可以同时配置多个规则：\n`Content-Security-Policy: frame-ancestors 'self' https://example.com`\n\n\n### 结论\n当你只需要配置不允许别人使用iframe加载你的网站或者只允许同源网站的时候，使用X-Frame-Options即可。如果你需要使用白名单的方式控制其行为，那么你应该使用`Content-Security-Policy: frame-ancestors`，它支持配置多个白名单而且具有更好的浏览器兼容性。\n\n当他们同时设置的时候，按规范`Content-Security-Policy: frame-ancestors`具有更高的优先级。但是现实往往不是如此，很多浏览器对此行为比不一致。建议只设置一个配置。\n\n#### 测试：\n> 这里以mac上面的几个常用浏览器为例，需要的小伙伴可以使用express自己在本地进行测试。\n\n比如请求头同时有以下两个配置:\n`Content-Security-Policy: frame-ancestors 'self' https://example.com`\n`X-Frame-Options: sameorigin`\n##### chrome v80\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/both-csp-xframe.png?raw=true)\n可以看到chrome是可以正常加载的\n\n##### safari v12\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/both-csp-xframe-safari.png?raw=true)\n可以看到safari先判断了x-frame-options，然后就阻止了页面加载。\n\n##### firefox v73\n![](https://github.com/u9646/u9646.github.io/blob/master/csp-frame-ancestors-vs-x-frame-options/both-csp-xframe-firefox.png?raw=true)\n可以看到火狐也是可以正常加载了\n","tags":["安全"]},{"title":"技术精选 - 第3期","url":"/hotlink-3/","content":"\n[最常见的6种Web应用漏洞及解决方案](https://mp.weixin.qq.com/s/M-O_Yv1-2Rfcw0scjxoRLQ)\nWeb应用基于C/S（Client/Server）服务模型搭建：客户端发送请求，服务端负责响应。一般客户端就是浏览器，但可以向服务器发送请求的软件则远远不限于浏览器。Web服务器通常以公开的域名接收请求并提供服务，需要应对任何来源的请求。\n\n[ARIA 实践指南](https://mp.weixin.qq.com/s/s9xVdhfswKk8x3qVXik3Hw)\nARIA 属于可访问性语义的范畴。从功能上来说，ARIA 的 roles、states 和 properties 类似于辅助技术的 CSS。对屏幕阅读器而言，ARIA 控制着它们的非视觉体验的渲染。\n\n[纯前端JS zip打包文件并下载](https://www.zhangxinxu.com/wordpress/2019/08/js-zip-download/?utm_medium=hao.caibaojian.com&utm_source=hao.caibaojian.com)\n如何实现ZIP打包下载\n\n[浅谈React性能优化的方向](https://mp.weixin.qq.com/s/WwKwX6HzT5HHxsGyx1YM1Q)\nReact 渲染性能优化的三个方向，其实也适用于其他软件开发领域，这三个方向分别是:减少计算的量,利用缓存,精确重新计算的范围\n\n[浅谈 Webpack 背后的运行机制](https://mp.weixin.qq.com/s/GQ4hJm7UPv2kcyh9-tW2aQ)\n在平时开发中我们经常会用到 Webpack这个时下最流行的前端打包工具。它打包开发代码，输出能在各种浏览器运行的代码，提升了开发至发布过程的效率。\n\n[你所不知道的 CSS 负值技巧与细节](https://mp.weixin.qq.com/s/GpcuCf9qZfJaotGluR-zXQ)\n写本文的起因是，一天在群里有同学说误打误撞下，使用负的 outline-offset 实现了加号。嗯？好奇的我马上也动手尝试了下，到底是如何使用负的 outline-offset 实现加号呢？\n\n[深度理解 React Suspense](https://mp.weixin.qq.com/s/ygVL3y-ElcNQosXbhs-k2w)\n在 16.6 版本之前，code-spliting 通常是由第三方库来完成的，比如 react-loadble(核心思路为: 高阶组件 + webpack dynamic import), 在 16.6 版本中提供了 Suspense 和 lazy 这两个钩子, 因此在之后的版本中便可以使用其来实现 Code Spliting。\n\n[Node.js 高级进阶之 fs 文件模块学习](https://mp.weixin.qq.com/s/vYWdALZ8DGpa9HNPOKkjTg)\n文件操作是开发过程中并不可少的一部分，作为一名 Node.js 开发工程师更应该熟练掌握fs模块的相关技巧。Node.js 中的 fs 模块是文件操作的封装，它提供了文件读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其它模块不同的是，fs 模块中所有的操作都提供了异步和同步的两个版本,具有 sync 后缀的方法为同步方法，不具有 sync 后缀的方法为异步方法\n","tags":["精选"]},{"title":"HTTP三次握手和四次挥手","url":"/http-three-way-handshake-and-wave-four-times/","content":"\n## 三次握手\n> 三次握手是指客户端在和服务端建立tcp连接的时候需要进行三次通信，然后才能完成连接。\n\n![image](https://upload-images.jianshu.io/upload_images/2179059-169363549c8e9f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这三次通信分别是:\n\n1. 客户端向服务端发送一个数据包，告诉服务端需要建立连接;\n2. 服务端收到客户端发送的数据包之后，会返回一个数据包，通知客户端，我已经收到你的连接请求;\n3. 客户端收到服务端返回的信息后，知道服务端已经准备好建立连接，但是还需要再发送一个数据包给服务端，用于告诉服务端我已经收到你的回复了。\n\n这个时候，连接就已经建立了。双方可以进行数据传输了。\n\n### 为什么一定需要三次连接呢?\n主要还是因为存在数据可能丢失的问题，也就是说不管是客户端或者服务端，都不能确定自己发出的信息对方有没有正常接收到，所以需要对方发送一个回复信息。用于确定自己发出的信息已经被对方正常接收。\n\n### 双方是如何确认对方的呢?\n比如服务端可能会同时接收多个客户端的连接请求，它是如何区分不同客户端的呢？答案就是随机值。\n\n客户端在第一次握手的时候，会生成一个随机数(j)，和数据包一起发送给服务端;\n\n第二次握手的时候，服务端会将这个随机值+1(j+1)，同时服务端也生成一个随机值(k)一起再返回给客户端;\n\n第三次握手的时候，客户端会检验j+1的值，如果检验通过，会将k+1，然后发送给服务端，服务端检验k+1的值，检验通过以后，连接就建立了。\n\n当然，实际的tcp连接中，数据包不只是包含随机值，同时还有各种标志位用于确认请求。\n\n### SYN攻击\n在三次握手过程中，当服务端发送SYN-ACK之后收到客户端的ACK之前的状态称为半连接状态，如果服务端一直没有收到客户端的ACK包，服务端需要不断重发直到超时。SYN攻击就是客户端在短时间内大量伪造不存在的ip地址，向服务端发起连接请求，由于源地址不存在，服务端一直不能收到客户端返回的ACK包，导致网络堵塞甚至系统瘫痪。SYN攻击是一种典型的DDOS攻击，如果服务端有大量半连接状态且源ip地址是随机的，则可以判断遭到SYN攻击。可以使用：\n\n```shell\n#netstat -nap | grep SYN_RECV\n```\n\n\n## 四次挥手\n> 四次挥手是指断开TCP连接时，需要客户端和服务端总共发送4次数据包以确认连接的断开\n\n![image.png](https://upload-images.jianshu.io/upload_images/2179059-9b09667fe6b27de1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n由于TCP连接是全双工的，因此，每个方向都需要单独进行关闭。这一原则是指当一方完成数据传输任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只意味着这一方向上没有数据传输，但在这个TCP连接上仍然能够发送数据，直到这一方向也发送FIN来。\n\n首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。\n\n1. 第一次挥手：client发送一个FIN，用来关闭client到server的数据传输，client进入FIN_WAIT_1状态；\n2. 第二次挥手：server收到FIN后，发送一个ACK给client，确认序号为收到序号+1，server进入CLOSE_WAIT状态；\n3. 第三次挥手：server发送一个FIN，用来关闭server到client的数据传输，server进入LAST_ACK状态；\n4. 第四次挥手：client收到FIN后，client进入TIME_WAIT状态，接着发送一个ACK给server，确认序号为收到序号+1，server进入CLOSE状态。\n\n完成四次挥手。\n\n### 为什么关闭连接需要四次挥手呢？\n这是因为当收到对方的FIN报文时，仅仅表示对方不再发送数据了，但是还能接收数据。己方也未必全部将数据都发送给对方了，所以己方可以立即CLOSE，也可以发送一个数据给对方后，再发送FIN报文给对方表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。\n\n### 为什么TIME_WAIT状态需要经过2MSL（最大报文段生存时间）才能返回到CLOSE状态？\n\n原因有二：\n\n1. 保证TCP协议的全双工连接能够可靠关闭；\n2. 保证这次连接的重复数据段从网络中消失。\n\n先说第一点，如果client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致server没有收到client最后回复的ACK。那么server就会在超时之后继续发送FIN，此时由于client已经CLOSED了，就找不到与重发的FIN对应的连接，最后server就会收到RST而不是ACK，server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。\n\n再说第二点，如果client直接CLOSED，然后又再向server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。\n","tags":["HTTP"]},{"title":"HTTP缓存之协商缓存和强制缓存","url":"/http-cache/","content":"\n通常根据是否需要向服务器重新发起HTTP请求去确认缓存是否有效将缓存分为强制缓存和协商缓存\n\n## 强制缓存\n`强制缓存`就是直接从浏览器缓存查找该结果，并根据结果的缓存规则来决定是否使用该缓存的过程。\n\n* 不存在该缓存结果和标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）\n* 存在缓存结果和标识，但结果已失效，强制缓存失效，则使用协商缓存\n* 存在缓存结果和标识，并且结果未失效，强制缓存生效，直接返回该结果\n\n控制强制缓存的字段分别是`Expires`和`Cache-Control`，其中`Cache-Control`优先级比`Expires`高。\n\n### Expires\n\n`Expires`是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于`Expires`的值时，直接使用缓存结果。\n\n#### `Expires`是HTTP/1.0的字段，但现在浏览器默认使用HTTP/1.1，那么HTTP/1.1中网页缓存是否还是由`Expires`控制？\n\n到了HTTP/1.1，`Expires`已经被`Cache-Control`替代，原因在于`Expires`控制缓存的原理是使用客户端的时间和服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区）发送误差，那么强制缓存则会直接失效。\n\n### Cache-Control\n在HTTP/1.1中，`Cache-Control`是最重要的规则，主要用于控制网页缓存，主要取值为：\n\n* `public`：所有内容都将被缓存（客户端/代理服务器/CDN等）\n* `private`：只有客户端可以缓存，`Cache-Control`默认值\n* `no-cache`：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n* `no-store`：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n* `max-age=xxx`：缓存将在xxx秒后失效\n\n> `Cache-Control/Expires`同时存在时，只有`Cache-Control`生效\n\n## 协商缓存\n`协商缓存`就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：\n\n1. 协商缓存生效，返回304，服务器告诉浏览器资源未更新，则再去浏览器缓存中访问资\n源\n2. 协商缓存失效，返回200和请求结果\n\n同样，协商缓存的标识也是在响应报文的HTTP头和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：\n\n* `Last-Modified/If-Modified-Since`\n* `Etag/If-None-Match`\n\n其中`Etag/If-None-Match`优先级比`Last-Modified/If-Modified-Since`高\n\n### Last-Modified/If-Modified-Since\n`Last-Modified`是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。\n\n`If-Modified-Since`则是客户端再次发起该请求时，携带上次请求返回的`Last-Modified`值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有`If-Modified-Since`字段，则会根据`If-Modified-Since`的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后修改时间大于`If-Modified-Since`的字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可以继续使用缓存文件。\n\n### Etag/If-None-Match\n`Etag`是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）。\n\n`If-None-Match`是客户端再次发起请求时，携带上次请求返回的唯一标识Etag值，服务端收到该请求后，发现该请求含有`If-None-Match`，则会根据`If-None-Match`的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件，否则重新返回资源，状态码为200.\n\n## 总结\n`强制缓存`优先于`协商缓存`，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。\n","tags":["HTTP"]},{"title":"技术精选 - 第2期","url":"/hotlink-2/","content":"\n[具有“脚本魔力”的属性们](https://mp.weixin.qq.com/s/8znEKWxCahJE1zSf9Zky_Q)\n属性的“脚本魔力”，是指仅仅通过一行简单的属性设置，就能实现看起来要 JS 才能完成的交互功能。包括但不限于\n\n[完全理解 redux（从零实现一个 redux）](https://mp.weixin.qq.com/s/jfDrhX6jMr36dRaFCH9Xbw)\n记得开始接触 react 技术栈的时候，最难理解的地方就是 redux。全是新名词：reducer、store、dispatch、middleware 等等，我就理解 state 一个名词。\n\n[用 Service Worker 实现前端性能优化](https://mp.weixin.qq.com/s/SLG_cDxDo7BaoQqAyLGa-Q)\n说起前端性能优化, 我们首先想到的可能就是用 Gulp 、Webpack 之类的自动化构建工具对 HTML、CSS 、JS 代码进行压缩，同时优化图片资源。再者就是使用 CSS Sprite 或者对于较小的图片用 base64 直接编码来进行优化。当然还有很多可以优化的方向，例如考虑浏览器缓存、页面渲染性能 ( 减少重排与重绘与 GPU 硬件加速 ) 、JS阻塞性能等等。但我们今天讲的是如何利用缓存策略在适宜的情况下直接减少对前端数据的请求量从而达到前端性能的优化。因此 Service Worker 以及其相关的 API 就成为了我们今天的主角。\n\n[TypeScript 技巧拾遗](https://mp.weixin.qq.com/s/pMGOecpnploICBqoAAg9fQ)\n很早以前就尝试过使用 TypeScript 来进行日常编码，但自己对静态类型语言的了解并不深入，再加上 TypeScript 的类型系统有着一定的复杂度，因此感觉自己并没有发挥好这门语言的优势，使代码变得更具可读性与可维护性。于是这几天便想着好好研究下这门语言，希望能够总结出一些特别的语言特性与实用技巧。\n\n[从零开始写一个符合Promises/A+规范的promise](https://mp.weixin.qq.com/s/JMnJUCVLMX15mTkIe4U6lQ)\n本篇主要讲解如何从零开始一步步的实现promise各项特性及功能，最终使其符合Promises/A+规范，因为讲解较细，所以文章略长。另外，每一步的项目源码都在github上，可以对照参考，每一步都有对应的项目代码及测试代码，喜欢的话，欢迎给个star~\n\n[「手摸手设计模式系列」享元模式与资源池](https://mp.weixin.qq.com/s/sPVuiUTOvu1KsRwEOhMQ2g)\n享元模式 （Flyweight Pattern）运用共享技术来有效地支持大量细粒度对象的复用，以减少创建的对象的数量。\n\n[前端中的编译原理 - 从零打造一个实用的 Babel 插件](https://mp.weixin.qq.com/s/XSzQ5nkLI369CDhMZtF-MQ)\n说起编译原理，可能我们脑海中首先浮现的就是 “编译器” 这个词汇。维基百科上对编译器的定义是：编译器是一种计算机程序，它会将某种编程语言写成的源代码（原始语言）转换成另一种编程语言（目标语言）。 通常一个编译器的编译过程会经过词法分析、语法分析、语义分析、生成中间代码、优化、生成目标代码这几个阶段。如果将其简要概括，则只包含 解析 ( parse ) 、转换 ( transform ) 、生成 ( generate ) 这三个阶段。\n\n[前端工程师需要了解的 Babel 知识](https://mp.weixin.qq.com/s/zQ5kCgoUbTOTqARI5o2cBQ)\n在前端圈子里，对于 Babel，大家肯定都比较熟悉了。如果哪天少了它，对于前端工程师来说肯定是个噩梦。Babel 的工作原理是怎样的可能了解的人就不太多了。\n","tags":["精选"]},{"title":"mongodb Query 和 Projection 常用操作符","url":"/mongodb-query-and-projection-operators/","content":"\n> [文档链接](https://docs.mongodb.com/manual/reference/operator/query/)\n\n## 比较运算符\n\n### $eq\n`{ <field>: { $eq: <value> } }`\n选择：等于某个值\n\n### $gt\n`{field: {$gt: value} }`\n选择：大于某个值\n\n### $gte\n`{field: {$gte: value} }`\n选择：大于等于某个值\n\n### $in\n`{ field: { $in: [<value1>, <value2>, ... <valueN> ] } }`\n选择：\n1. filed是一个值，并且等于value1 or value2 ...\n1. field是个数组，并且filed中至少存在某个值等于value1 or value2 ...\n\n### $lt\n`{field: {$lt: value} }`\n选择：小于某个值\n\n### $lte\n`{ field: { $lte: value} }`\n选择：小于等于某个值\n\n### $ne\n`{field: {$ne: value} }`\n\n选择：\n1. field不等于某个值\n2. field不存在\n\n### $nin\n`{ field: { $nin: [ <value1>, <value2> ... <valueN> ]} }`\n\n选择：\n1. field值不存在于数组中\n2. field不存在\n\n## 逻辑运算符\n### $and\n`{ $and: [ { <expression1> }, { <expression2> } , ... , { <expressionN> } ] }`\n\n选择同时匹配所有expression的数据\n\n> 如果expression1为false，则mongodb不会继续后续的判断\n\n### $not\n`{ field: { $not: { <operator-expression> } } }`\n\n选择所有不符合operator-expression的数据。\n\n```\n// 选择所有price小于等于1.99或者price字段不存在的数据\ndb.inventory.find( { price: { $not: { $gt: 1.99 } } } )\n```\n\n### $nor\n`{ $nor: [ { <expression1> }, { <expression2> }, ...  { <expressionN> } ] }`\n\n选择同时不满足所有expression的数据\n\n### $or\n`{ $or: [ { <expression1> }, { <expression2> }, ... , { <expressionN> } ] }`\n\n选择至少满足一个expression的数据\n\n## 元素运算符\n### $exists\n`{ field: { $exists: <boolean> } }`\n\n选择filed是否存在的数据，$exists: true代表存在，false代表不存在\n\n### $type\n`{ field: { $type: <BSON type> } }`\n选择filed是某个具体类型的实例的数据，可以写具体type或者对应数字\n\n具体BSON type可以看文档：https://docs.mongodb.com/manual/reference/operator/query/type/#document-type-available-types\n\n## 数组运算符\n### $all\n`{ <field>: { $all: [ <value1> , <value2> ... ] } }`\n\n选择filed是个数组，并且包含所有value1 and value2 ...\n\n### $elemMatch\n`{ <field>: { $elemMatch: { <query1>, <query2>, ... } } }`\n\n选择filed是个数组并且至少有一个元素满足query1 or query2 ...\n\n> 如果query只有一个，那么你不需要使用$elemMatch\n\n### $size\n`db.collection.find( { field: { $size: 2 } } );`\n\n选择filed数组长度等于某个值的数据\n\n## projection运算符\n\n### $\n```\n// 示例数据\n{ \"_id\" : 1, \"semester\" : 1, \"grades\" : [ 70, 87, 90 ] }\n{ \"_id\" : 2, \"semester\" : 1, \"grades\" : [ 90, 88, 92 ] }\n{ \"_id\" : 3, \"semester\" : 1, \"grades\" : [ 85, 100, 90 ] }\n{ \"_id\" : 4, \"semester\" : 2, \"grades\" : [ 79, 85, 80 ] }\n{ \"_id\" : 5, \"semester\" : 2, \"grades\" : [ 88, 88, 92 ] }\n{ \"_id\" : 6, \"semester\" : 2, \"grades\" : [ 95, 90, 96 ] }\n\n// 只返回grades数组的第一个元素\ndb.students.find( { semester: 1, grades: { $gte: 85 } },\n                  { \"grades.$\": 1 } )\n// 结果为：\n{ \"_id\" : 1, \"grades\" : [ 87 ] }\n{ \"_id\" : 2, \"grades\" : [ 90 ] }\n{ \"_id\" : 3, \"grades\" : [ 85 ] }\n\n// { \"grades.$\": 1 } 这里的1只是代表显示grades字段\n```\n\n### $elemMatch\n用于控制数据返回值，只会显示某个字段第一个满足$elemMatch的元素\n\n```\n// 示例数据\n{\n _id: 1,\n zipcode: \"63109\",\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: \"63110\",\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: \"63109\",\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: \"63109\",\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n              { name: \"ruth\", school: 102, age: 16 },\n           ]\n}\n\ndb.schools.find( { zipcode: \"63109\" },\n                 { students: { $elemMatch: { school: 102 } } } )\n// 结果为：\n{ \"_id\" : 1, \"students\" : [ { \"name\" : \"john\", \"school\" : 102, \"age\" : 10 } ] }\n{ \"_id\" : 3 }\n{ \"_id\" : 4, \"students\" : [ { \"name\" : \"barney\", \"school\" : 102, \"age\" : 7 } ] }\n\n\n\ndb.schools.find( { zipcode: \"63109\" },\n                 { students: { $elemMatch: { school: 102, age: { $gt: 10} } } } )\n// 结果为：\n{ \"_id\" : 1, \"students\" : [ { \"name\" : \"jess\", \"school\" : 102, \"age\" : 11 } ] }\n{ \"_id\" : 3 }\n{ \"_id\" : 4, \"students\" : [ { \"name\" : \"ruth\", \"school\" : 102, \"age\" : 16 } ] }\n```\n\n### $slice\n`db.collection.find( { field: value }, { array: {$slice: count } } )`\n\n用于控制某个数组字段返回多少个元素\n\n```\n// 返回comments前5个元素\ndb.posts.find( {}, { comments: { $slice: 5 } } )\n\n// 返回最后5个元素\n//db.posts.find( {}, { comments: { $slice: -5 } } )\n```\n\n$slice还可以是个数组，即[skip, limit]，表明跳到第skip个元素，从这里选择limit个。\n\n```\n// 跳过前20个元素，然后开始往后选择10个\ndb.posts.find( {}, { comments: { $slice: [ 20, 10 ] } } )\n\n// 从倒数第20个元素开始，往后选择10个元素\ndb.posts.find( {}, { comments: { $slice: [ -20, 10 ] } } )\n```\n\n还有一些其他操作符，可以参考文档。\n","tags":["mongodb"]},{"title":"技术精选 - 第1期","url":"/hotlink-1/","content":"\n[网站性能指标这么多，你到底选对了吗](https://mp.weixin.qq.com/s/ITb0IWzLPj715NUgL7C4HA)\n从用户体验角度来看一个网址或者app是否有吸引力，75%的人是认为页面加载时长是一个核心因素，远远高于其他影响用户体验的问题，例如：简洁易用、屏幕适配、设计吸引力等等。\n\n[npm install 原理分析](https://mp.weixin.qq.com/s/byX6V6fL9O1SuEdppZO2CA)\n开门见山，npm install 大概会经过上面的几个流程，本篇文章来讲一讲各个流程的实现细节、发展以及为何要这样实现。\n\n[Webpack 插件开发如此简单！](https://mp.weixin.qq.com/s/nimOuftziXCWHV61FfjWog)\n本文将带你一起开发第一个 Webpack 插件，从 Webpack 配置工程师，迈向 Webpack 开发工程师！\n\n[让你牛B加身的前端必会Linux命令](https://mp.weixin.qq.com/s/80UEbeEfPBV2LMmRqJFT7w)\n本文主要针对于 FEer 们。作为前端，一开始我们总是和 HTML/JavaScript/CSS 三大块打交道，但是久而久之，我们就会接触更多的内容，比如服务的部署。而这一块对于我们的要求会更全面，其中对 Linux 指令就有很多要求。如果你想要部署服务，而又没有成熟的工具或平台可以借助，需要完全自己来操作的话，你就需要准备好部署服务需要的所有文件、登录指定的服务器、发布指定文件、启动服务、服务器启动不成功时候进行调试以及服务维护过程中进行问题的排查。本文就将从这一条线讲起，分享歪马在工作中所积累的一些实用指令。\n\n[给你梳理了 44 个 CSS 精选知识点](https://mp.weixin.qq.com/s/Pw3VgFpijTYRkJyYPvlJgA)\n一个周五的晚上，闲来无事整理下自己的 github（经常做收藏党），今天打算都过一遍，发现一个 star很高的项目，里面有大量的 CSS 片段，而且标题很诱人，然后又花了将近1个小时从头到尾过了一遍，其中一些是我们常用的一些知识点，另外也包含一些比较新的属性的应用，知识点挺多的，为了让大家看起来更方便些，然后又花了点（很长很长）时间翻译成中文。\n\n[你必须懂的前端性能优化](https://mp.weixin.qq.com/s/DdbaiuZd4RbqUod0jhn_vg)\n从输入 URL 到页面加载完成的过程：\n\n首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来\n 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了\n\n[深入理解 JavaScript 原型](https://mp.weixin.qq.com/s/qg9LNm3awHBao1Du5n6KMQ)\nPrototype 是 JavaScript 里的一个基础概念，原本应该很容易理解。然而，出于各种原因，大部分前端开发者（包括我），在刚开始学习 JS 时，原型和原型链都是一个需要克服的困难。\n\n[Promise 链式调用顺序引发的思考](https://mp.weixin.qq.com/s/zTVRIwmA_9oQ-Ea_b1oqqA)\n近一个多月没有写博客了，前阵子一个朋友问我一个关于 Promise 链式调用执行顺序的问题\n","tags":["精选"]},{"title":"mongodb 增删改查CURD基本操作总结","url":"/mongodb-curd-api/","content":"\n> 基于[mongodb v4.2](https://docs.mongodb.com/manual/introduction/)\n\n## 插入数据\n\n### 插入一条数据\n`db.collection.insertOne()` 插入一个文档到集合中\n\n```\ntry {\n   db.products.insertOne( { item: \"card\", qty: 15 } );\n} catch (e) {\n   print (e);\n};\n// 返回值：\n{\n   \"acknowledged\" : true,\n   \"insertedId\" : ObjectId(\"56fc40f9d735c28df206d078\")\n}\n```\n\n### 插入多条数据\n`db.collection.insertMany()` 同时插入多条数据到集合中\n\n```\ntry {\n   db.products.insertMany( [\n      { item: \"card\", qty: 15 },\n      { item: \"envelope\", qty: 20 },\n      { item: \"stamps\" , qty: 30 }\n   ] );\n} catch (e) {\n   print (e);\n}\n// 返回值：\n{\n   \"acknowledged\" : true,\n   \"insertedIds\" : [\n      ObjectId(\"562a94d381cb9f1cd6eb0e1a\"),\n      ObjectId(\"562a94d381cb9f1cd6eb0e1b\"),\n      ObjectId(\"562a94d381cb9f1cd6eb0e1c\")\n   ]\n}\n```\n\ninsert 特性：\n如果当前集合不存在，会自动创建一个集合。\n\n_id 属性：\nmongodb里面，如果你不提供_id，mongodb会默认在插入文档的时候为每一个文档创建一个唯一的_id，作为主键\n\n\n## 查找数据\nmongodb可以使用`find`方法查找数据\n\n### 普通查询\n\n> 每个文档插入到集合中如果不提供一个_id字段，则mongodb会自动生成一个，并且在查询语句中默认返回，这里省略没有显示该字段\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"A\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" }\n]);\n```\n\n```\n// 查找 size 等于 { h: 14, w: 21, uom: \"cm\" } 的数据\ndb.inventory.find( { size: { h: 14, w: 21, uom: \"cm\" } } )\n// or 查找 qty 等于 25 的数据\ndb.inventory.find({ qty: 25 })\n// or 使用嵌套查询 size 的 uom 等于 in 的数据\ndb.inventory.find( { \"size.uom\": \"in\" } )\n// $lt 小于\ndb.inventory.find( { \"size.h\": { $lt: 15 } } )\n// 复合条件查询，查询 size.h 小于 15， 并且 size.uom 等于 in，并且 status 等于 D 的数据\ndb.inventory.find( { \"size.h\": { $lt: 15 }, \"size.uom\": \"in\", status: \"D\" } )\n```\n\n### 查询数组\n```\n// 示例数据\ndb.inventory.insertMany([\n   { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"], dim_cm: [ 14, 21 ] },\n   { item: \"notebook\", qty: 50, tags: [\"red\", \"blank\"], dim_cm: [ 14, 21 ] },\n   { item: \"paper\", qty: 100, tags: [\"red\", \"blank\", \"plain\"], dim_cm: [ 14, 21 ] },\n   { item: \"planner\", qty: 75, tags: [\"blank\", \"red\"], dim_cm: [ 22.85, 30 ] },\n   { item: \"postcard\", qty: 45, tags: [\"blue\"], dim_cm: [ 10, 15.25 ] }\n]);\n```\n\n```\n// 查询 tags 等于 [\"red\", \"blank\"] 的数据\ndb.inventory.find( { tags: [\"red\", \"blank\"] } )\n\n// 或者你想查询tags包含 red blank，不管它的顺序，或者是否还有其他元素，你可以使用 `$all`\ndb.inventory.find( { tags: { $all: [\"red\", \"blank\"] } } )\n\n// 查询tags 里面包含 red的数据\ndb.inventory.find( { tags: \"red\" } )\n\n// 查询dim_cm里面最少有一个值大于 25\ndb.inventory.find( { dim_cm: { $gt: 25 } } )\n\n/*\n** 查询dim_cm里面:\n** 1. 有一个元素同时满足大于15并且小于20\n** 2. 有两个分别满足小于15以及大于20\n*/\ndb.inventory.find( { dim_cm: { $gt: 15, $lt: 20 } } )\n// 所以结果是返回这四条：\n{ \"item\" : \"journal\", \"qty\" : 25, \"tags\" : [ \"blank\", \"red\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"notebook\", \"qty\" : 50, \"tags\" : [ \"red\", \"blank\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"paper\", \"qty\" : 100, \"tags\" : [ \"red\", \"blank\", \"plain\" ], \"dim_cm\" : [ 14, 21 ] }\n{ \"item\" : \"postcard\", \"qty\" : 45, \"tags\" : [ \"blue\" ], \"dim_cm\" : [ 10, 15.25 ] }\n\n// 查询dim_cm里面至少有一个元素同时满足大于22并且小于30的数据\ndb.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } )\n\n// 查询dim_cm第二个元素大于25的数据\ndb.inventory.find( { \"dim_cm.1\": { $gt: 25 } } )\n\n// 查询dim_cm的tags数组长度为3的数据\ndb.inventory.find( { \"tags\": { $size: 3 } } )\n```\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", instock: [ { warehouse: \"A\", qty: 5 }, { warehouse: \"C\", qty: 15 } ] },\n   { item: \"notebook\", instock: [ { warehouse: \"C\", qty: 5 } ] },\n   { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 15 } ] },\n   { item: \"planner\", instock: [ { warehouse: \"A\", qty: 40 }, { warehouse: \"B\", qty: 5 } ] },\n   { item: \"postcard\", instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] }\n]);\n\n// 查询instock数组里面有一个元素为{ warehouse: \"A\", qty: 5 }的数据，必须warehouse等于A并且qty等于5，包括顺序也必须一致\ndb.inventory.find( { \"instock\": { warehouse: \"A\", qty: 5 } } )\n\n// 查询instock数组里面至少有一个元素的qty字段值小于等于20的数组\ndb.inventory.find( { 'instock.qty': { $lte: 20 } } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"notebook\", \"instock\" : [ { \"warehouse\" : \"C\", \"qty\" : 5 } ] }\n{ \"item\" : \"paper\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 60 }, { \"warehouse\" : \"B\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n{ \"item\" : \"postcard\", \"instock\" : [ { \"warehouse\" : \"B\", \"qty\" : 15 }, { \"warehouse\" : \"C\", \"qty\" : 35 } ] }\n\n// 查询instock数组的第一个元素的qty字段小于等于20的数据\ndb.inventory.find( { 'instock.0.qty': { $lte: 20 } } )\n\n// 查询instock数组里至少有一个元素同时满足qty等于5并且warehouse等于A的数组\ndb.inventory.find( { \"instock\": { $elemMatch: { qty: 5, warehouse: \"A\" } } } )\n\n// 查询instock数组里至少有一个元素的qty同时满足大于10并且小于等于20\ndb.inventory.find( { \"instock\": { $elemMatch: { qty: { $gt: 10, $lte: 20 } } } } )\n\n// 查询instock数组里至少有一个元素满足大于10或者小于等于20\ndb.inventory.find( { \"instock.qty\": { $gt: 10,  $lte: 20 } } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"paper\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 60 }, { \"warehouse\" : \"B\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n{ \"item\" : \"postcard\", \"instock\" : [ { \"warehouse\" : \"B\", \"qty\" : 15 }, { \"warehouse\" : \"C\", \"qty\" : 35 } ] }\n\n// 查询instock里任意一个元素的qty等于5并且任意一个元素的warehouse等于A的数据\ndb.inventory.find( { \"instock.qty\": 5, \"instock.warehouse\": \"A\" } )\n// 结果为：\n{ \"item\" : \"journal\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 5 }, { \"warehouse\" : \"C\", \"qty\" : 15 } ] }\n{ \"item\" : \"planner\", \"instock\" : [ { \"warehouse\" : \"A\", \"qty\" : 40 }, { \"warehouse\" : \"B\", \"qty\" : 5 } ] }\n```\n\n### 控制查询语句输出结果\n默认情况下，查询语句会返回文档的所有字段，我们可以通过第二个参数来自定义返回文档里的哪些字段\n\n关于第一个参数，我们这里就不详细说明了，可参考上面\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n  { item: \"journal\", status: \"A\", size: { h: 14, w: 21, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 5 } ] },\n  { item: \"notebook\", status: \"A\",  size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"C\", qty: 5 } ] },\n  { item: \"paper\", status: \"D\", size: { h: 8.5, w: 11, uom: \"in\" }, instock: [ { warehouse: \"A\", qty: 60 } ] },\n  { item: \"planner\", status: \"D\", size: { h: 22.85, w: 30, uom: \"cm\" }, instock: [ { warehouse: \"A\", qty: 40 } ] },\n  { item: \"postcard\", status: \"A\", size: { h: 10, w: 15.25, uom: \"cm\" }, instock: [ { warehouse: \"B\", qty: 15 }, { warehouse: \"C\", qty: 35 } ] }\n]);\n\n// 返回所有文档的status为的A的数据的所有字段\ndb.inventory.find( { status: \"A\" } )\n\n// 只返回文档的item, status字段以及_id（默认显示），1代表显示，0则是不显示\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1 } )\n\n// 如果想要_id也不返回，可以这样：\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, _id: 0 } )\n\n// 也可以单独给某些不想显示的字段设为0，其余的正常显示\ndb.inventory.find( { status: \"A\" }, { status: 0, instock: 0 } )\n\n// 还可以控制嵌套对象的字段，下面语句只显示_id, item, status, 以及size的uom字段\ndb.inventory.find(\n   { status: \"A\" },\n   { item: 1, status: 1, \"size.uom\": 1 }\n)\n\n// 也可以只设置不显示某个嵌套字段，下面语句不显示size的uom属性，其余正常显示\ndb.inventory.find(\n   { status: \"A\" },\n   { \"size.uom\": 0 }\n)\n\n// 控制数组中的元素某些字段是否显示\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, \"instock.qty\": 1 } )\n// 结果为：\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d51\"), \"item\" : \"journal\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 5 } ] }\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d52\"), \"item\" : \"notebook\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 5 } ] }\n{ \"_id\" : ObjectId(\"5e639b35940e1ec922af0d55\"), \"item\" : \"postcard\", \"status\" : \"A\", \"instock\" : [ { \"qty\" : 15 }, { \"qty\" : 35 } ] }\n\n// 对于instock，只返回数组的最后一个元素\ndb.inventory.find( { status: \"A\" }, { item: 1, status: 1, instock: { $slice: -1 } } )\n\n// $elemMatch, $slice 和 $ 是唯一能控制数组返回字段的方法，在这里，不可以使用类似于：{ 'instock.0': 1 }这种控制只显示instock数组的第一个元素的。\n```\n\n### 如何显示null或者缺失字段\n```\n// 示例数据\ndb.inventory.insertMany([\n   { _id: 1, item: null },\n   { _id: 2 }\n])\n\n// item设为null时，会返回null，以及不存在该字段的数据，比如第二条数据不存在item字段，也会被返回\ndb.inventory.find( { item: null } )\n// 结果为：\n{ \"_id\" : 1, \"item\" : null }\n{ \"_id\" : 2 }\n\n// 如果想要精确匹配，可以这样：\n// 10 是Null类型的数值表示，具体可看：https://docs.mongodb.com/manual/reference/bson-types/，里面有各种类型对应的数值\ndb.inventory.find( { item : { $type: 10 } } )\n// 结果为：\n{ \"_id\" : 1, \"item\" : null }\n\n// 还可以使用$exists操作符，用于标明字段是否存在\ndb.inventory.find( { item : { $exists: false } } )\n// 结果为：\n{ \"_id\" : 2 }\n// 如果$exists设为true，则返回：\n{ \"_id\" : 1, \"item\" : null }\n```\n\n### 使用游标操作数据\n\n```\n// 可以将find的返回值保存到一个变量中\nvar myCursor = db.users.find( { type: 2 } );\n\nwhile (myCursor.hasNext()) {\n   print(tojson(myCursor.next()));\n}\n\n// 可以使用printjson代替print(tojson()\nvar myCursor = db.users.find( { type: 2 } );\n\nwhile (myCursor.hasNext()) {\n   printjson(myCursor.next());\n}\n\n// 还可以使用游标的forEach方法\nvar myCursor =  db.users.find( { type: 2 } );\n\nmyCursor.forEach(printjson);\n```\n\n游标对象的具体有哪些方法可以看：https://docs.mongodb.com/manual/reference/method/#js-query-cursor-methods\n\n\n## 更新数据\n\n更新数据主要使用：\n* `db.collection.updateOne(<filter>, <update>, <options>)`\n* `db.collection.updateMany(<filter>, <update>, <options>)`\n* `db.collection.replaceOne(<filter>, <update>, <options>)`\n\nmongodb提供了更新操作符去更新数据，比如$set，具体可看文档：https://docs.mongodb.com/manual/reference/operator/update/\n\n有一些操作符，比如$set在字段不存在时会自动添加该字段\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"canvas\", qty: 100, size: { h: 28, w: 35.5, uom: \"cm\" }, status: \"A\" },\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"mat\", qty: 85, size: { h: 27.9, w: 35.5, uom: \"cm\" }, status: \"A\" },\n   { item: \"mousepad\", qty: 25, size: { h: 19, w: 22.85, uom: \"cm\" }, status: \"P\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" },\n   { item: \"sketchbook\", qty: 80, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"sketch pad\", qty: 95, size: { h: 22.85, w: 30.5, uom: \"cm\" }, status: \"A\" }\n] );\n\n// 第一个参数这里也不继续说明了，详细可以看上面查询部分\n\n/*\n** 1. 更新size的uom字段值为cm\n** 2. 更新status字段值为P\n** 3. 更新lastModified为当前时间，如果lastModified字段不存在，会添加该字段\n*/\ndb.inventory.updateOne(\n   { item: \"paper\" },\n   {\n     $set: { \"size.uom\": \"cm\", status: \"P\" },\n     $currentDate: { lastModified: true }\n   }\n)\n// 更新后的数据：\n{ \"_id\" : ObjectId(\"5e6466a4940e1ec922af0d5b\"), \"item\" : \"paper\", \"qty\" : 100, \"size\" : { \"h\" : 8.5, \"w\" : 11, \"uom\" : \"cm\" }, \"status\" : \"P\", \"lastModified\" : ISODate(\"2020-03-08T03:29:48.653Z\") }\n\n// 更新多条数据\ndb.inventory.updateMany(\n   { \"qty\": { $lt: 50 } },\n   {\n     $set: { \"size.uom\": \"in\", status: \"P\" },\n     $currentDate: { lastModified: true }\n   }\n)\n\n/*\n** 替换数据\n** 1. _id字段不能被替换，如果新数据里包含_id字段，则值必须和原数据的一致\n** 2. 新数据不能包含操作符\n*/\ndb.inventory.replaceOne(\n   { item: \"paper\" },\n   { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 40 } ] }\n)\n```\n\n`upsert`属性\n如果`updateOne()`, `updateMany()` 或者 `replaceOne()`包含`upsert: true`参数时，如果这三个方法没有匹配到任何文档，则会创建一个新的插入到集合中，如果匹配到了，则会修改或者替换原文档。\n\n### 使用聚合更新数据\n在聚合中可以使用一下更新操作符：\n* $addFields\n* $set\n* $project\n* $unset\n* $replaceRoot\n* $replaceWith\n\n```\n// 示例数据\ndb.students.insertMany([\n   { _id: 1, test1: 95, test2: 92, test3: 90, modified: new Date(\"01/05/2020\") },\n   { _id: 2, test1: 98, test2: 100, test3: 102, modified: new Date(\"01/05/2020\") },\n   { _id: 3, test1: 95, test2: 110, modified: new Date(\"01/04/2020\") }\n])\n\n/*\n** updateOne方法第二个参数可以是以数组，里面可以有多种操作\n** 1. 新增一个test3字段并设为98\n** 2. 修改modified数据值为当前时间\n*/\ndb.students.updateOne( { _id: 3 }, [ { $set: { \"test3\": 98, modified: \"$$NOW\"} } ] )\n\n\n// 示例数据\ndb.students2.insertMany([\n   { \"_id\" : 1, quiz1: 8, test2: 100, quiz2: 9, modified: new Date(\"01/05/2020\") },\n   { \"_id\" : 2, quiz2: 5, test1: 80, test2: 89, modified: new Date(\"01/05/2020\") },\n])\n\n/*\n** 同时执行多个操作，首先序列化所有文档（集合中的每个文档字段可能并不一致），再更新modified字段\n** 1. 序列化文档，如果文档中没有 quiz1 or quiz2 or test1 or test2 就给它添加该字段，并将值设为0。该操作可以用于将集合中所有文档的字段保持一致\n** 2. 更新文档的modified为当前时间\n*/\ndb.students2.updateMany( {},\n  [\n    { $replaceRoot: { newRoot:\n       { $mergeObjects: [ { quiz1: 0, quiz2: 0, test1: 0, test2: 0 }, \"$$ROOT\" ] }\n    } },\n    { $set: { modified: \"$$NOW\"}  }\n  ]\n)\n// 结果为：\n{ \"_id\" : 1, quiz1: 8, quiz2: 9, test1: 0, test2: 100, modified: new Date(\"01/05/2020\") }\n{ \"_id\" : 2, quiz1: 0, quiz2: 5, test1: 80, test2: 89, modified: new Date(\"01/05/2020\") }\n\n// 示例数据\ndb.students3.insert([\n   { \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") },\n   { \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") },\n   { \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n]);\n\n/*\n** 设置average, grade字段值，并且修改modified值\n** 1.1 设置average字段（如果没有会新增）为tests数组的平均值，0代表保留0个小数，即取证，具体可看$trunc操作符文档https://docs.mongodb.com/manual/reference/operator/aggregation/trunc/\n** 1.2 设置modifed字段为当前时间\n** 1 设置grade字段，根据average的值分别设为A,B,C,D,F\n*/\ndb.students3.updateMany(\n   { },\n   [\n     { $set: { average : { $trunc: [ { $avg: \"$tests\" }, 0 ] }, modified: \"$$NOW\" } },\n     { $set: { grade: { $switch: {\n                           branches: [\n                               { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" },\n                               { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" },\n                               { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" },\n                               { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" }\n                           ],\n                           default: \"F\"\n     } } } }\n   ]\n)\n// 结果为：\n{ \"_id\" : 1, \"tests\" : [ 95, 92, 90 ], \"average\": 92, \"grade\": \"A\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n{ \"_id\" : 2, \"tests\" : [ 94, 88, 90 ], \"average\": 90, \"grade\": \"A\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n{ \"_id\" : 3, \"tests\" : [ 70, 75, 82 ], \"average\": 75, \"grade\": \"C\", \"modified\" : ISODate(\"2019-01-01T00:00:00Z\") }\n\n// 示例数据\ndb.students4.insertMany([\n  { \"_id\" : 1, \"quizzes\" : [ 4, 6, 7 ] },\n  { \"_id\" : 2, \"quizzes\" : [ 5 ] },\n  { \"_id\" : 3, \"quizzes\" : [ 10, 10, 10 ] }\n])\n\n// 在quizzes后追加[8, 6]\ndb.students4.updateOne( { _id: 2 },\n  [ { $set: { quizzes: { $concatArrays: [ \"$quizzes\", [ 8, 6 ]  ] } } } ]\n)\n// 结果为\n{ \"_id\" : 2, \"quizzes\" : [ 5, 8, 6 ] }\n\n// 示例数据\ndb.temperatures.insertMany([\n  { \"_id\" : 1, \"date\" : ISODate(\"2019-06-23\"), \"tempsC\" : [ 4, 12, 17 ] },\n  { \"_id\" : 2, \"date\" : ISODate(\"2019-07-07\"), \"tempsC\" : [ 14, 24, 11 ] },\n  { \"_id\" : 3, \"date\" : ISODate(\"2019-10-30\"), \"tempsC\" : [ 18, 6, 8 ] }\n])\n\n/*\n** 1. 新增tempsF字段\n** 2. 将tempsC数组里的摄氏度转换为华氏度 f = c * 1.8 + 32\n*/\ndb.temperatures.updateMany( { },\n  [\n    { $addFields: { \"tempsF\": {\n          $map: {\n             input: \"$tempsC\",\n             as: \"celsius\",\n             in: { $add: [ { $multiply: [\"$$celsius\", 9/5 ] }, 32 ] }\n          }\n    } } }\n  ]\n)\n// 结果为：\n{ \"_id\" : 1, \"date\" : ISODate(\"2019-06-23\"), \"tempsC\" : [ 4, 12, 17 ], \"tempsF\": [39.2, 53.6, 62.6] }\n{ \"_id\" : 2, \"date\" : ISODate(\"2019-07-07\"), \"tempsC\" : [ 14, 24, 11 ], \"tempsF\": [57.2, 75.2, 51.8] }\n{ \"_id\" : 3, \"date\" : ISODate(\"2019-10-30\"), \"tempsC\" : [ 18, 6, 8 ], \"tempsF\": [64.4, 42.8, 46.4] }\n```\n\n### update方法\n具体可看文档：https://docs.mongodb.com/manual/reference/update-methods/\n\n* `db.collection.updateOne()`\n* `db.collection.updateMany()`\n* `db.collection.replaceOne()`\n* `db.collection.update()`\n\n* `db.collection.findOneAndReplace()`\n* `db.collection.findOneAndUpdate()`\n* `db.collection.findAndModify()`\n* `db.collection.save()`\n* `db.collection.bulkWrite()`\n\n## 删除数据\n可以使用下面方法删除数据\n\n* `db.collection.deleteMany()`\n* `db.collection.deleteOne()`\n\n```\n// 示例数据\ndb.inventory.insertMany( [\n   { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" },\n   { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" },\n   { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" },\n   { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" },\n   { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" },\n] );\n\n// 删除inventory所有数据\ndb.inventory.deleteMany({})\n\n// 删除所有匹配的数据\ndb.inventory.deleteMany({ status : \"A\" })\n\n// 删除匹配到的第一条数据\n//db.inventory.deleteOne( { status: \"D\" } )\n```\n\n删除操作不会删除索引，即使删掉所有文档\n","tags":["mongodb"]}]